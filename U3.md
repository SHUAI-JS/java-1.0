U3重点:
ssm(Spring框架+SpringMVC框架+Mybatis框架)
Maven项目管理工具

#                  Maven项目管理工具day01_maven

​                                    

## 目标:

1.介绍Maven
2.Maven的工作原理
3.Maven相关知识
4.Idea使用Maven

## 一、Maven(项目构建工具)

### 1.什么是maven

基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤.
       

### 2.Maven的功能:

管理项目的依赖、编译项目、打包项目、运行项目、发布项目、生成报告、部署项目（部署）   

## 二、Maven的工作原理(理解为管理项目包的工具)

![image-20200625154850854](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625154850854.png)

## 三、maven的相关知识

### 1.maven的相关概念

中央仓库: 线上存储jar的位置
本地仓库: 在pc端本地存储jar的位置
Pom文件:在项目中使用pom文件引用jar包（如果本地仓库有，就直接复制一份到项目，如果本地仓库没有就到中央仓库下载，存储到本地仓库，然后在从本地仓库中复制一份到项目中，项目中所有需要的包都是通过pox.xml文件得到的）

### 2.安装maven工具

#### 1.从官网去下载:maven的安装包

#### 2.解压安装包即可(必需先装JDK)

将包解压到d:/maven目录

### 3.配置环境变量

#### 3.1 在环境变量中添加一个M2_HOME环境变量

M2_HOME   值为maven的安装目录:D:\maven\apache-maven-3.3.9

#### 3.2修改path变量添加以下配置

;%M2_HOME%\bin;

#### 3.3测试是否安装成功

**在命令行中输入:mvn -v**![](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625154339146.png)

### 4.设置maven的本地仓库和中央仓库(可选的:如果不进行设置采用默认配置)

Maven安装目录中/conf/settings.xml文件
注意:如果不设置，采用默认的配置

#### 4.1设置本地仓库的位置

找到setting文件，设置本地仓库的位置

```xml
<!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: ${user.home}/.m2/repository  -->
  <localRepository>d:\maven\repository</localRepository>
```

注意:在d:\\maven下创建repository目录

注意:在d:\\maven下创建repository目录

4.2设置中央仓库的位置(推荐使用阿里云的中央仓库)

```xml
   <mirrors>
    <!-- mirror
     | Specifies a repository mirror site to use instead of a given repository. The repository that
     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
     |
    <mirror>
      <id>mirrorId</id>
      <mirrorOf>repositoryId</mirrorOf>
      <name>Human Readable Name for this Mirror.</name>
      <url>http://my.repository.com/repo/path</url>
    </mirror>
     -->
	 <!--把Maven中央仓库换成阿里云-->
    <mirror>
      <id>alimaven</id>
      <name>aliyun maven</name>
      <url>
          http://maven.aliyun.com/nexus/content/groups/public/
      </url>
      <mirrorOf>central</mirrorOf>        
    </mirror>
  </mirrors>
```



### 5.maven工程的标准目录结构（重点）

![image-20200625154929608](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625154929608.png)

## 四、idea中使用maven  (idea中已经安装了maven)

![image-20200625154939572](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625154939572.png)

![image-20200625154954328](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625154954328.png)

## 五、在idea中创建maven工程

![image-20200625155008857](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625155008857.png)

普通java工程

![image-20200625155019647](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625155019647.png)

## 六、理解pom文件

 

```java
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!--定义组名-->
    <groupId>com.team</groupId>
    <!--项目名称-->
    <artifactId>mone</artifactId>
    <!--项目版本-->
    <version>1.0-SNAPSHOT</version>
    <!--添加第三方的jar包，添加依赖-->
    <dependencies>
        <!-- MySQL依赖 start -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.25</version>
        </dependency>
    </dependencies>
</project>
```

注意:在以下地址中去查找相关jar的依赖
https://mvnrepository.com/    

## 七、理解maven的常用命令

![image-20200625155042073](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625155042073.png)



















------







# 				==Mybatis第一章day02_mybatis_ch01==

回顾maven工程的目录结构:
工程名
  Pom..xml maven工程管理文件
  Src
     Main  程序目录
       Java   java源码目录
       Resources 程序资源文件目录
     Test   测试目录
        java源码目录
        Resources 程序资源文件目录

三层架构:

![image-20200625171529144](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625171529144.png)



## 课程目标:

1.理解框架
2.理解数据持久化概念和ORM原理  重点 难点
3.理解MyBatis的概念以及优点特性
4.（重点）搭建MyBatis环境实现年级查询功能
5.了解MyBatis与JDBC的区别与联系
MyBatis就是JDBC封装

## 一、框架

### 1.为什么需要框架技术

问题一: 如何更快更好地写简历？

![image-20200625171847042](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625171847042.png)

答: 使用word简历模板

问题二： 那使用模板有哪些好处呢?
不用考虑布局、排版等，提高效率
可专心在简历内容上
结构统一，便于人事阅读
新手也可以作出专业的简历

### 2.什么是框架技术

框架是一个[应用程序的半成品]()，提供可重用的公共结构。按照规则组织的一组组件.

### 3.框架优点 ：

不用考虑公共问题、专心在业务实现上、结构统一易于维护、[提高开发效率]()

### 4.常用框架

[Mybatis、Spring->SpringBoot、SpringMVC  、]()Strtus2、Hibernate
[SMM:Spring+SpringMvc+Mybatis]()
[SSH: Spring+Struts2|Springmvc+Hibernate]()

## 二、理解持久化与ORM的概念

### 1.持久化:

持久化是程序[**数据在瞬时状态**]()与**[持久状态]()**之间的转换过程.

![image-20200625172140892](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625172140892.png)

### 2.(必需会)ORM（Object Relational Mapping）:对象关系映射

[a)编写程序的时候，以面向对象的方式处理数据]()
[b)保存数据的时候，却以关系型数据库的方式存储]()
注意:Mybatis是ORM[半自动化]()(写sql)实现、而Hibernate是ORM全(无需编写sql)实现

![image-20200625172229921](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625172229921.png)

## 三、Mybatis

### 1.介绍MyBatis

MyBatis(前身ibatis)是Orm的半自动化（编写sql）实现，充当[持久化框架。]()

### 2.(重点)搭建Mybatis的开发环境

#### 2.1添加mybatis相关的jar包(在pom.xm文件中添加依赖)

```xml
 <!-- MySQL依赖 start -->
<dependency>
 <groupId>mysql</groupId>
 <artifactId>mysql-connector-java</artifactId>
 <version>5.1.25</version>
</dependency>
<!-- MySQL依赖 end -->
<!-- 加入MyBatis 依赖 start -->
<dependency>
 <groupId>org.mybatis</groupId>
 <artifactId>mybatis</artifactId>
 <version>3.2.5</version>
</dependency>
<!-- 加入MyBatis 依赖 end -->
```



#### 2.2在工程中添加mybatis的配置文件(mybatis-config.xml),并放在resources目录中

   a. 指定连接数据库的配置
   b. 加载sql映射文件(定义的持久化操作)

```java
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 指定义连接数据的配置 -->
   <environments default="development">
      <environment id="development">
      <transactionManager type="JDBC"/>
         <dataSource type="POOLED">
         <property name="driver" value="com.mysql.jdbc.Driver"/>
         <property name="url" value=" jdbc:mysql://localhost:3306/k0501db?useUnicode=true&amp;characterEncoding=utf-8
"/>
         <property name="username" value="root"/>
         <property name="password" value="123"/>
         </dataSource>
      </environment>
   </environments>


   <!-- 加载sql映射文件-->
   <mappers>
      <mapper resource=" com/team/project/dao/GradeMapper.xml"/>
</mappers>
</configuration>
```



#### 2.3.编写sql映射文件(文件名称:表名+Mapper.xml)，并放到接口包中

注意: sql映射文件中存放的都是sql语句(一个sql语句一个功能一个[持久化操作]())

```java
<mapper namespace="com.team.project.dao.GradeDao">
   <!--注意:namespace属性指定持久化操作存放的包，推荐包名用接口的限定名-->
    <!--定义一系列的持久化操作-->
   <!--定义一个查询的持久化操作
   id属性表示操作的名称,  推荐id值为接口的方法名称
   resultType 表示查询语句返回的实体类型
   -->

    <select id="getAllGrade" resultType="com.team.project.entity.Grade">
      select * from grade
   </select>

</mapper>
```

[注意: namespace的值推荐使用接口包的限定名
注意:sql映射文件一定义要在mybatis配置文件进行引入]()

注意: namespace的值推荐使用接口包的限定名
注意:sql映射文件一定义要在mybatis配置文件进行引入

## 四、创建maven实现查询所有年级

### 1.创建maven工程和还原数据

![image-20200625172537871](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625172537871.png)

### 2.创建Grade实体

```java
 public class Grade {
    private int gid;
    private String gname;
   setter和getter略
}
```

### 3.编写Dao层实现查询年级

接口:

```java
public interface GradeDao {
   public List<Grade> getAllGrade();
}
```

实现:  使用Mybatis调用持久操作的步骤

```java
public class GradeDaoImpl implements GradeDao {
    @Override
    public List<Grade> getAllGrade() {
        try {
            //------编写sql,使用jdbc技术 
            //------使用Mybatis实现
            //1.将sql语句定义在sql映射文件中
            //2.Mybatis执行调用持久化操作
            //2.1读取配置文件
            Reader reader=Resources.getResourceAsReader("mybatis-config.xml");
            //2.2获取SqlSessionFactory工厂
            SqlSessionFactoryBuilder sqlSessionFactoryBuilder=new SqlSessionFactoryBuilder();
            SqlSessionFactory sqlSessionFactory=sqlSessionFactoryBuilder.build(reader);
            //2.3获取SqlSession对象调用持久化操作
            SqlSession sqlSession=sqlSessionFactory.openSession();
            //2.4调用持久化操作
            //sqlSession.selectList("持久化操作的id值");
            List<Grade> grades= sqlSession.selectList("com.kgc.dao.GradeDao.getAllGrade");
             //2.5关闭sqlSession
            sqlSession.close();
            return grades;
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }
}
```







在mybatis工程运行时: Could not find resource com/kgc/dao/GradeMapper.xml
解决：maven编译|打包工程时，[默认不支持将java目录中的配置文件进行打包]()，所以就会报找不到文件
在pom文件中添加以下代码

```java
<build>
    <!--配置相关的资源进行打包-->
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.xml</include>最好把xml换成*号，*号包含所有
            </includes>
        </resource>
    </resources>
</build>
```











------



# 				Mybatis第二章day03_mybatis_ch02



## 课程目标

1.实现mybatis单表的增删改查(重点)
2.利用ResultMap标签定义返回结果 
3.省略Dao层实现类

## 一、实现mybatis单表的增删改查

### 1.实现添加功能

#### 1.1定义添加持久化操作

```java
<!--添加持久化操作  建议:id的属性值与方法名相同
   parameterType持定义参数的类型（读取的参数类型）
  在sql语句使用#{属性名|键名}进行占位
-->
<insert id="addGrade" parameterType="com.team.project.entity.Grade">
   insert into grade(gid,gname) values(#{gid},#{gname})
</insert>
```

### 2.实现修改功能

#### 2.1定义修改的持久化操作

```java
<!--修改持久化操作-->
<update id="updateGrade" parameterType="com.team.project.entity.Grade">
    update grade set gname=#{gname} where gid=#{gid}
</update>
```

### 3.实现删除功能

#### 3.1定义删除的持久化操作 

```java
<!-- 删除持久化
parameterType 指定参数类型
注意:mybatis定义内置的java类型别名
java类型               别名
java.lang.Integer      int
-->
<delete id="deleteGrade" parameterType="int">
    delete from grade where gid=#{gid}
</delete>
```

### 4.实现查询单条记录

```java
<!--定义查询单条-->

<select id="getGrade" parameterType="int" resultType="com.team.project.entity.Grade">
    select * from grade where gid=#{gid}
</select>


```

### 5.查询

```java
<select id="getAllGrade" resultType="com.team.project.entity.Grade">
   select * from grade
</select>
```







## 二、sqlSession调用持久化操作的方法

### 1.添加方法

sqlSession.insert(“添加持久化操作”[,参数对象])

### 2.修改方法

sqlSession.update(“修改持久化操作”[,参数对象])

### 3.删除方法

sqlSession.delete(“删除持久化操作”[,参数对象])

### 4.查询单条

sqlSession.selectOne(“查询的持久化操作” [,参数对象]);

### 5.查询

sqlSession.selectList(“查询的持久化操作” [,参数对象]);

[**注意: 如果执行添加，修改，删除操作时，mybatis需要基于事务执行(需要提交或者回滚)**]()

## 三、（了解）ResultMap标签自定义返回结果类型(用在返回复杂结构)

示例:执行查询时使用ResultMap属性返回结果
[注意:查询持久化操作resultType和resultMap两个属性不能同时存在
resultType指定返回实体的属必需要与表的字段名称相同才返回获取结果
resultMap指定自定义返回结果(指定属性列的列应关联)]()

```java
 <!--ResultMap自定义结果类型，type是返回类型-->
   <resultMap id="gradeResult" type="com.team.project.entity.Grade">
       <!--指定哪个属性与哪个列对应-->
       <id property="gid" column="gid"></id>
       <!--<result property="gid" column="gid"></result>-->
       <result property="gname" column="gname"></result>
   </resultMap>
     
        <select id="getAllGrade" resultMap="gradeResult">
   select gid,gname from grade
</select>
```







## [四、(重点)使用sqlSession对象的getMapper方法动态生成代理实现类(省dao层实现类)

**命名空间解释：**

（C++提供名字空间将相同的名bai字放在不du同空间中来防止命名zhi冲突;
大型应用程序有多人完成,各自为自dao己的模块命名,名字冲突是一种潜在的危机;比如甲在程序中定义了int a；乙也在程序中定义了int a；在最后就会出现命名冲突，此时就会用到命名空间了。）

在mybatis开发中:无需编写dao层实现类]()
 [注意:sql映射文件中的命名空间必需是接口的限定名称, 持久化操作的id属性值必需和接口的方法名称相同]()

```java
 public static void main(String[] args) {
    //查询所有年级
    //使用SqlSession的getMapper方法生成dao层接口的动态代理实现类对象
    try {
        //1.获取sqlSession对象
        Reader reader = Resources.getResourceAsReader("mybatis-config.xml");
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder=new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory=sqlSessionFactoryBuilder.build(reader);
        SqlSession sqlSession=sqlSessionFactory.openSession();
        //2.使用getMapper生成接口的代理实现类对象
        //必需满足以下条件:
        // 1.sql映射文件的命名空间的值必需是接口的限定名
        // 2.接口中的方法名称必需与持久化操作id值相同
        GradeDao gradeDao=sqlSession.getMapper(GradeDao.class);
        //3.调用方法
        List<Grade> list=gradeDao.getAllGrade();
        //4.显示
        System.out.println("编号\t名称");
        list.forEach(grade -> {
            System.out.println(grade.getGid()+"\t"+grade.getGname());
        });
    } catch (IOException e) {
        e.printStackTrace();
    }
}


```

## 五、其它: [mybatis定义内置的java类型别名]() 

内置类型别名  java类型
_int      int
	   _short    short
       _long     long
       _float     float
[int       java.lang.Integer
float      java.lang.Float
double    java.lang.Double
list       java.uitl.List
arraylist   java.uitl.ArrayList
map      java.uitl.Map]()

 总结

1. parameterType持定义参数的类型（读取的参数类型）
2. #{属性名|键名}进行占位
3. resultType="com.team.project.entity.Grade"返回参数类型







[^Mybatis第二章day03_mybatis_ch02结束]: 



------

# ==Mybatis动态sql ，Mybatis第三章day04_mybatis_ch03==



## 课程目标

1.回顾使用Mybatis查询所有学生信息
     理解Dao层的实现过程

2. 介绍Mybatis动态sql能力  重点
3. 实现学生信息的搜索功能
4. 实现年级的批量删除

## 一、回顾:

功能:使用Mybatis查询所有学生信息
     理解Dao层的实现过程
1.创建学生实体

```java
public class Student {
   //推荐属性的数据类型使用类类型
  private Integer xh;
  private String name;
  private String sex;
  private Integer age;
  private Date birthday;
  private String address;
  private Integer state;
  private Integer gid;
setter和getter略
}
```

2.编写dao层接口

```java
//一个表一个实体一个接口一个sql映射文件
public interface StudentDao {
   //一个功能一个方法一个持久化操作
    public List<Student> getAllStudent();
}
```

3.编写持久化操作

```java
<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.team.project.dao.StudentDao">
   <!--持久化操作-->
    <select id="getAllStudent" resultType="com.team.project.entity.Student">
        select * from student
    </select>
</mapper>
```



[注意:编写了sql映射文件，一定要在mybatis配置文件中添加sql映射文件]()





4.测试dao层

```java
 public static void main(String[] args) {
    //调用dao层
    try {
        Reader reder=Resources.getResourceAsReader("mybatis-config.xml");
        //2.获取SqlSessionFactory工厂
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder=new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory=sqlSessionFactoryBuilder.build(reder);
        SqlSession sqlSession= sqlSessionFactory.openSession();   
//创建DAO对象
    //getMapper sql映射文件的命名空间值与接口限定名相同，方法名与持久化操作id值相同
    StudentsDao studentsDao=sqlSession.getMapper(StudentsDao.class);
    List<Students> list=studentsDao.getAllStudent();
    sqlSession.close();  //关闭
    //显示
    System.out.println("学号\t姓名\t年龄\t性别\t生日\t状态");
    list.forEach(s -> {
        System.out.println(s.getXh()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getSex()+"\t"+s.getBirthday()+"\t"+s.getState());
    });
} catch (Exception e){

}
}
```


[Mybatis总结:
一个表一个实体一个Dao接口一个sql映射文件(一系列的持久化操作)
编写功能时:一个功能一个dao方法一个持久化操作.]()



## 二、Mybatis动态sql能力(拼接sql语句)

MyBatis 的一个强大的特性之一通常是它的[动态 SQL 能力]()。 如果你有使用 JDBC 或其他 相似框架的经验,你就明白条件地串联 SQL 字符串在一起是多么的痛苦,确保不能忘了空 格或在列表的最后省略逗号。动态 SQL 可以彻底处理这种痛苦。 
通常使用动态 SQL 不可能是独立的一部分,[MyBatis 当然使用一种强大的动态 SQL 语 言来]()改进这种情形,这种语言可以被用在任意映射的 SQL 语句中。 
动态 SQL 元素和使用 JSTL 或其他相似的基于 XML 的文本处理器相似。在 MyBatis 之 前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半 的元素就能工作了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。 
1.if()
2.choose (when, otherwise)
3.trim (where, set)()
4.foreach



## 三、实现学生信息的搜索功能

需求:

![image-20200625182232668](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200625182232668.png)

### 1.创建条件实体类

作用:封装查询条件,一个搜索条件为一个属性

```java
//搜索条件的实体
public class StudentCondition {
   //一个查询条件就一个属性
   private String name;   //姓名
   private Integer startAge; //开始年龄
   private Integer endAge;  //结束年龄
   Setter和getter方法略
}
```

### 2.编写dao层

#### 2.1编写dao层接口的方法

```java
//通过条件查询学生
public List<Student> searchStudent(StudentCondition studentCondition);
```

​     

​     

#### 2.2编写持久化操作:根据条件动态生成sql

```java
<select id="searchStudent"
  parameterType="com.kgc.entity.StudentCondition"
resultType="com.kgc.entity.Student">
<!--动态拼接sql-->
 SELECT * FROM students where 1=1
 <if test="name!=null">
and name like concat('%',#{name},'%')
 </if>
 <if test="startAge!=null">
  and age > #{startAge}
 </if>
 <if test="endAge!=null">
  and age &lt; #{endAge}
 </if>
</select>
<!--注意:不能出现特殊字符 如:<(&lt;)  

<!--      SELECT * FROM students
     <where>
        <if test="name!=null">
           and name like concat('%',#{name},'%')
        </if>
        <if test="startAge!=null">
           and age > #{startAge}
        </if>
        <if test="endAge!=null">
           and age &lt; #{endAge}
        </if>
     </where>-->
<select>
```







### 3.测试调用dao层

```java
/*实现搜索学生    测方式dao层*/
public static void main(String[] args) throws Exception {
    //一、用户输入信息   jsp表单
    Scanner input=new Scanner(System.in);
    System.out.println("请输入姓名:");
    String name=input.nextLine();  //没有输入内容""
    System.out.println("请输入开始年龄:");
    String startAge=input.nextLine();
    System.out.println("请输入结束年龄:");
    String endAge=input.nextLine();
```



```java
//二、将用户输入的信息封装查询条件里   Servlet
StudentCondition studentCondition=new StudentCondition();
if(!name.equals("")){
    studentCondition.setName(name);
}
if(!startAge.equals("")){
    studentCondition.setStartAge(new Integer(startAge));
}
if(!endAge.equals("")){
    studentCondition.setEndAge(new Integer(endAge));
}
```


```java
///1.获得sqlSession对象
Reader reader=Resources.getResourceAsReader("mybatis-config.xml");
SqlSessionFactoryBuilder sqlSessionFactoryBuilder=new SqlSessionFactoryBuilder();
SqlSessionFactory sqlSessionFactory=sqlSessionFactoryBuilder.build(reader);
SqlSession sqlSession=sqlSessionFactory.openSession();
//2.利用sqlSession生成接口的动态代理实现
StudentDao studentDao=sqlSession.getMapper(StudentDao.class);
//3.调用dao层搜索的方法   传条件
List<Student> list=studentDao.searchStudent(studentCondition);
//显示
System.out.println("学号\t姓名\t年龄\t性别\t生日");
list.forEach(s -> {
    System.out.println(s.getXh()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getSex()+"\t"+s.getBirthday());
});
//关闭sqlSession
sqlSession.close();
}
```


## 四、实现批量(多项)删除功能：同时删除多个年级

### 1.编写dao层

接口方法:

```java
//批量删除  传递list集合或者数组
//public int deleteMoreGrade(List<Integer>  gids);
public int deleteMoreGrade(Integer [] gids);
```

持久化操作:

```java
<!--删除多项的持久化操作
你可以传递一个 List 实例或者数组作为参数对象传给 MyBatis。
当你这么做的时 候,MyBatis 会自动将它包装在一个 Map 中,用名称在作为键。
List 实例将会以“list” 作为键,而数组实例将会以“array”作为键。
-->
<delete id="deleteMoreGrade">
DELETE FROM grade WHERE gid IN
<foreach collection="array" item="gid" open="(" close=")" separator=",">
   #{gid}   
</foreach>
</delete>
```

 

### 2.测试 dao层

```java
/*删除多个年级*/
public static void main(String[] args) throws Exception {
    //使用数组存放要删除的编号
    Integer [] gids={45,46,47};
      //测试调用dao层删除多项
    //1.获得sqlSession对象
    Reader reader=Resources.getResourceAsReader("mybatis-config.xml");
    SqlSessionFactoryBuilder sqlSessionFactoryBuilder=new SqlSessionFactoryBuilder();
    SqlSessionFactory sqlSessionFactory=sqlSessionFactoryBuilder.build(reader);
    SqlSession sqlSession=sqlSessionFactory.openSession();
    //2.利用sqlSession生成接口的动态代理实现
    GradeDao gradeDao=sqlSession.getMapper(GradeDao.class);
    //调用方法
    int temp=gradeDao.deleteMoreGrade(gids);
    sqlSession.commit();  //删除需要提交
    sqlSession.close();
if(temp>0)
    System.out.println("成功删除"+temp+"行");
else
    System.out.println("删除失败");
    }
```

















------

# 反向工程，day05_mybatis_ch04

## 课程目标

1.Mybatis指定实体类型的别名 (会)
2.Mybatis反向工程(重点，熟练)
3.使用反向工程selectByExample方法实现查询(会)
4.Mybatis连接查询（下节课继续讲）

## 一、配置mybatis的实体类型的别名 (修改:mybatis的配置文件)

```java
 <typeAliases>
        <!--1.利用typeAlias为某个实体类取别名
        <typeAlias type="com.kgc.entity.Grade" alias="Grade"></typeAlias>
        -->
    <!--2.使用package为包下所有的实体类型取别名
       name 指定包名、生成实体的别名就是类名
    -->
    <package name="com.team.project.entity"></package>
</typeAliases>
```

  注意:
 Configuration标签出现子元素的顺序:
properties,settings,[typeAliases](),typeHandlers,objectFactory,objectWrapperFactory,plugins,[environments](),databaseIdProvider,[mappers]()

  注意:
 Configuration标签出现子元素的顺序:
properties,settings,typeAliases,typeHandlers,objectFactory,objectWrapperFactory,plugins,environments,databaseIdProvider,mappers

## 二、(重点)使用Mybatis的反向工程([自动生成:实体类、接口、sql映射文件]())

回顾:mybatis的dao层组件有哪些:实体、接口、sql映射文件

### 1.实现mybatis的反向工程的步骤

#### 1.1在pom文件中导入mybatis自动生成的jar包(mybatis-generator-core)

```java
<!--mybatis自动生成的依赖包-->
<dependency>
    <groupId>org.mybatis.generator</groupId>
    <artifactId>mybatis-generator-core</artifactId>
    <version>1.3.3</version>
</dependency>
```

#### 1.2 在工程中编写mybatis自动生成的配置文件(generator.xml)

   注意:放在resources目录

```java
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!—1.指定数据的驱动包-->
  <classPathEntry location="D:\mysql-connector-java-5.1.0-bin.jar" />

  <context id="Mysql2Tables" targetRuntime="MyBatis3">
    <commentGenerator>
      <property name="suppressDate" value="true"></property>
      <property name="suppressAllComments" value="true"></property>
    </commentGenerator>

   <jdbcConnection driverClass="com.mysql.jdbc.Driver"
        connectionURL="jdbc:mysql://localhost:3306/k9051db"
        userId="root"
        password="123">
    </jdbcConnection>

    <javaTypeResolver >
      <property name="forceBigDecimals" value="false" />
    </javaTypeResolver>

    <!--指定生成实体所有在的包
注意:
 如果项目是创建的工程  targetProject=”src/main/java”
如果项目是创建的模块 targetProject=”模块项目名称/ src/main/java”
-->
    <javaModelGenerator targetPackage="com.kgc.grade.entity" targetProject="mybatis_ch04/src/main/java">
      <property name="enableSubPackages" value="true" />
      <property name="trimStrings" value="true" />
    </javaModelGenerator>

      <!--指定sql映射文件的位置-->
      <sqlMapGenerator targetPackage="com.kgc.grade.dao"  targetProject="mybatis_ch04/src/main/java">
      <property name="enableSubPackages" value="true" />
    </sqlMapGenerator>

      <!--指定接口存放的位置-->
    <javaClientGenerator type="XMLMAPPER" targetPackage="com.kgc.grade.dao"  targetProject="mybatis_ch04/src/main/java">
      <property name="enableSubPackages" value="true" />
    </javaClientGenerator>

  <!--添加需要反向工程的表-->
  <table  tableName="grade" enableCountByExample="false" enableUpdateByExample="false"
          enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">
  </table>
  <table  tableName="students" enableCountByExample="false" enableUpdateByExample="false"
          enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">
  </table>
  </context>
</generatorConfiguration>
```



#### 1.3 运行自动生成的工具类(MybatisGeneratorUtil.java)

将工具类复制到项目中，并运行即可

####  1.4 修改mybatis的配置文件，加载所有的sql映射文件

```java
<!-- 加载sql映射文件-->
<mappers>
    <!--添加映射文件
    <mapper resource="com/kgc/mapper/GradeMapper.xml"></mapper>
   <mapper resource="com/kgc/mapper/StudentMapper.xml"></mapper>
    -->
   <!--加载某个包下所有sql映射文件-->
   <package name="com.kgc.mapper"></package>
</mappers>
```

## 三、使用反向工程生成文件(代码)

测试添加:添加年级
略

### 1.测试查询所有

#### 1-1添加查询所有年级的方法

```java
 //查询所有年级
List<Grade> getAllGrade();
```

#### 1-2添加查询所有年级的持久操作

```java
 <!--查询所有年级-->
<select id="getAllGrade" resultType="Grade">
  select * from grade
</select>
```

#### 1-3测试查询所有

```java
  public static void main(String[] args) {
    //1.使用mybatis工具类获得sqlSession
    SqlSession sqlSession=MyBatisUtil.getSession();
    //2.生成dao层的对象
    GradeMapper gradeMapper=sqlSession.getMapper(GradeMapper.class);
    //3.调用dao层方法查询所有
    List<Grade> list=gradeMapper.getAllGrade();
    //4.关闭资源
    MyBatisUtil.closeSession();

    //显示结果
    System.out.println("编号\t名称");
    list.forEach(grade -> {
        System.out.println(grade.getGid()+"\t"+grade.getGname());
    });
}
//使用mybatis的工具类获取sqlSession
```




## 四、利用反向工程的selectByExample方法进行查询(条件查询)

### 1.修改自动生成的配置文件，将以下开关打开，启动selectByExample

```java
 <table  tableName="grade" enableCountByExample="false" enableUpdateByExample="false"
        enableDeleteByExample="false" enableSelectByExample="true" selectByExampleQueryId="false">
</table>
```



### 2.调用dao层的selectByExample实现查询

```java
public static void main(String[] args) {
    //获取sqlSession
    SqlSession sqlSession=MyBatisUtil.getSession();
    //创建dao层对象
    StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);
    //一、使用selectByExample进行查询所有
    //StudentExample studentExample=new StudentExample();  //相当于就是查询语句
    //List<Student> list=studentMapper.selectByExample(studentExample);

    //二、使用selectByExample进行条件查询
    StudentExample studentExample=new StudentExample();  //相当于就是查询语句
    //添加查询条件
    StudentExample.Criteria criteria=studentExample.createCriteria();
    criteria.andAgeLessThan(new Byte("30"));  //拼sql
    criteria.andNameLike("%王%");

    List<Student> list=studentMapper.selectByExample(studentExample);
    //关闭sqlSession
    MyBatisUtil.closeSession();

    //显示结果
    System.out.println("学号\t姓名\t年龄\t性别\t生日\t年级");
    list.forEach(s -> {
        System.out.println(s.getXh()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getSex()+"\t"+s.getBirthday()+"\t"+s.getGid());
    });

}
```









------





# 			    ==Mybatis的执行连接查询,day06_mybatis_ch05 关联映射==

## 课程目标

1.Mybatis执行连接查询(多对一)
业务：查询所有学生及对应的年级信息 
2.(重点理解)类与类之间的关系
3.(重点)使关联映射实现从属查询
 (一对多查询)
业务:显示每个年级及年级下的学生

## 一、实现查询所有学生及对应的年级名称:-连接查询

回顾连接查询

### -- 回顾连接查询的语法

1.连接查询分类

INNER JOIN 指内连接、left JOIN 左外连接、right JOIN 右外连接

2.连接查询语法

SELECT * FROM 表1 INNER JOIN 表2 ON 表1.公共字段=表2.公共字段

#### 1.修改学生实体类添加年级名称属性

Private String gname;
Setter和getter方略

#### 2.编写dao层

接口:

```java
//查询所有学生及对应的年级名称
List<Student> getAllStudentInfo();
```

持久化操作:

```java
<!--查询学生及关联的年级名称-->
<select id="getAllStudentInfo" resultType="Student">
  SELECT student.*,gname FROM student LEFT JOIN grade
    ON student.gid=grade.`gid`
</select>
```

#### 3.测试

```java
public static void main(String[] args) {
   //测试dao
    //1.获取dao层对象
    SqlSession sqlSession=MyBatisUtil.getSession();
    StudentsMapper studentsMapper=sqlSession.getMapper(StudentsMapper.class);
    //2.调用
    List<Students> list=studentsMapper.selectStudentInfo();
    //3.显示数据
    System.out.println("学号\t姓名\t年龄\t性别\t生日\t年级名称");
    list.forEach(s -> {
        System.out.println(s.getXh()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getSex()+"\t"+s.getBirthday()+"\t"+s.getGname());
    });
}
```

## 二、理解：类与类之间的关系

### 1.表与表之间的关系

#### 1.1 构成关系:

表与表之间是通过主外键(公共字段)形成的关系

#### 1.2关系的分类

1对1、1对多、多对1、多对多

### 2.类与类之间的关系

#### 2.1 利用类的属性实现类与类之间的关系

人类Person

```java
public class Person{
   //定义车对象
   Car car=new Car();   //一个人只能开一辆车,1对1关系
    
   //定义车的集合对象，一个人可以拥有多辆车，一对多关系
   List<Car> cars=new ArrayList<Car>();  //1对多关系
}
```

车类Car

```java
Public class Car{
   //定义人对旬,一辆车只能属于一个人
   Person person=new Person();  //1对1 或者 多对1
//坐多个人，一两车上可以坐多个人，一对多关系 
   List<Person> plist=new ArrayList<Person>();  //一对多关系
}
```

#### 2.2 类与类之间的关系:1对1 、1对多、多对1、多对多

## 三、从属查询(一对多查询):查询年级信息及每个年级对应的学生信息

使用mybatis的关系映射

需求分析:

![image-20200626114115423](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626114115423.png)

### 1.修改年级实体类(一对多关系)：实现一个年级多名学生的关系

```java
public class Grade {
    private Short gid;
    private String gname;
    //添加学生集合属性:实现一个年级多名学生
    private List<Students> students=new ArrayList<>();
    public List<Students> getStudents() {
        return students;
    }
    public void setStudents(List<Students> students) {
        this.students = students;
    }
}
```

### 2.编写dao层

接口:

```java
//查询年级及对应的学生
List<Grade>  getGradeBelongStu();
```

持久化操作:利用mybatis的关联映射实现一对多查询

```java
<!--查询所有年级及对应的学生
   执行连接查询，利用resultMap返回复杂结果的映射
   实现一对多的映射
  -->
  <resultMap id="result1" type="Grade">
      <id column="gid" property="gid"></id>
      <id column="gname" property="gname"></id>
      <!--使用collection实现一对多的关联映射
        property  指定集合属性
        javaType 指定是集合的类型
        ofType 指定集合关联的泛型
        notNullColumn="xh"  指定学号，如果学号为空时不返回对象，不为空时返回对象
       autoMapping="true"  实现属性和列的自动映射(字段名要与属性名相同)
-->
      <collection property="students" javaType="list" ofType="Student" notNullColumn="xh"  autoMapping="true">
<!--
        <id column="xh" jdbcType="INTEGER" property="xh" />
        <result column="name" jdbcType="VARCHAR" property="name" />
        <result column="age" jdbcType="TINYINT" property="age" />
        <result column="sex" jdbcType="VARCHAR" property="sex" />
        <result column="birthday" jdbcType="DATE" property="birthday" />
        <result column="state" jdbcType="TINYINT" property="state" />
        <result column="address" jdbcType="VARCHAR" property="address" />
        <result column="gid" jdbcType="INTEGER" property="gid" />
--> 
      </collection>
  </resultMap>
      <select id="getGradeBelongStu" resultMap="result1">
     SELECT * FROM grade LEFT JOIN student
ON grade.`gid`=student.gid
  </select>
```







测试dao的代码:

```java
public static void main(String[] args) {
    //获取sqlSession
    SqlSession sqlSession=MyBatisUtil.getSession();
    //创建dao层对象
    GradeMapper gradeMapper=sqlSession.getMapper(GradeMapper.class);
    List<Grade> list= gradeMapper.getGradeBelongStu();
    //显示
    System.out.println("编号\t名称");
    list.forEach(grade -> {
        System.out.println(grade.getGid()+"\t"+grade.getGname());
        System.out.println("显示该年级的下的学生....");
        //获取当前年级的学生
        List<Student> students=grade.getStudents();
        students.forEach(s -> {
            System.out.println("====学号:"+s.getXh()+"=姓名:"+s.getName()+"=年龄:"+s.getAge()+"=性别:"+s.getSex());
        });
    });
 sqlSession.close();
}
```

## 四、resultType和resultMap的区别

注意: resultType和resultMap不能共存

### 1.resultMap用于返回复杂结果(比如:1对多关联射)类型:手动实现字段与属性映射

理解为自定义返回结果

### 2.resultType返回非关联映射的结果

自动返回结果

## 五、(不推荐 )实现查询所有学生及对应的年级名称.(多对一)

利用mybatis的关联映射

### 1.修改学生的实体类，添加年级对象属性(实现一个学生对应一个年级)

```java
 public class Student {
      学生相关的属性….
    //关联年级对象     
    private Grade grade;      
    public Grade getGrade() {
        return grade;
    }
    public void setGrade(Grade grade) {
        this.grade = grade;
    }
}
```

### 2.编写dao层方法查询所有学生及对应的年级

```java
//查询年级及对应的学生
List<Student> getAllStudentInfo2();
```

### 3.编写持久化操作  利用resultMap实现多对一关联映射

```java
<!--查询学生关联的年级    多对一的映射-->
<resultMap id="result1" type="Student">
  <id column="xh" jdbcType="INTEGER" property="xh" />
  <result column="name" jdbcType="VARCHAR" property="name" />
  <result column="age" jdbcType="TINYINT" property="age" />
  <result column="sex" jdbcType="VARCHAR" property="sex" />
  <result column="birthday" jdbcType="DATE" property="birthday" />
  <result column="state" jdbcType="TINYINT" property="state" />
  <result column="address" jdbcType="VARCHAR" property="address" />
  <result column="gid" jdbcType="INTEGER" property="gid" />
  <!--使用association实现多（一）对一映射-->
  <association property="grade" javaType="Grade">
    <result column="gname" jdbcType="VARCHAR" property="gname" />
  </association>
</resultMap>
      <select id="getGradeBelongStu" resultMap="result1">
     SELECT * FROM grade LEFT JOIN student
ON grade.`gid`=student.gid
  </select>
```



### 4.编写主函数测试查询

```java
public static void main(String[] args) {
    //调用dao层执行持久化操作得到结果
    SqlSession sqlSession= MyBatisUtil.getSession();
    //创建dao层对象
    StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);
    List<Student> list=studentMapper.getAllStudentInfo2();
    //输出信息
    System.out.println("学号\t姓名\t年龄\t性别\t生日\t年级名称");
    list.forEach(s -> {
        System.out.println(s.getXh()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getSex()+"\t"+s.getBirthday()+"\t"+s.getGrade().getGname());
    });
MyBatisUtil.closeSession();
}
```









------

# sringmvc基础，day07_ch01

## 课程目标

1.理解mvc设计模式
2.(重点)介绍Springmvc和Springmvc工作原理
3.使用Idea创建Maven web工程并添加Tomcat插件运行工程
4.(重点)搭建Springmvc的开发环境
5.使用Springmvc实现登入

理解控制器的创建
理解ModelAndView对象

回顾:三层架构

![image-20200626161445435](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626161445435.png)

## 一、MVC设计模式(思想)

### 1.理解MVC的术语

M(Model):模型层   对应组件:JavaBean
V(VIEW):视图层  对应组件:HTML或者 Jsp
C(Controller):控制器  对应的组件:Servlet

### 2.Jsp+servlet+Javabean(Model 2模式)开发模式与Mvc的关系

Jsp+servlet+javabean是实现mvc思想

![image-20200626161755553](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626161755553.png)

### 3.mvc的优点和缺点:

MVC 优点
a)多视图共享一个模型，大大提高代码的可重用性
b)MVC三个模块相互独立，松耦合架构
c)控制器提高了应用程序的灵活性和可配置性
d)有利于软件工程化管理

完美的系统架构 = 松耦合+高重用性+高扩展性

MVC 缺点
原理复杂
增加了系统结构和实现的复杂性
视图对模型数据的低效率访问

## 二、springmvc框架

### 1.介绍springmvc框架

Springmvc框架是spring框架的子集，实现MVC思想的产物.
注意:常用mvc框架:Springmvc、struts2

### 2.(重点)Springmcv的工作原理

用户—发请求核心控制器(DispatcherServlet)—分发请求用户控制器--调用模型层
视图进行呈现<--ModelAndView(视图模型对象)--返回

![image-20200626162110532](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626162110532.png)

## 三、创建maven的web工程并用插件运行

### 1.使用idea创建maven的web工程

![image-20200626163654705](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626163654705.png)

![image-20200626163710014](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626163710014.png)

### 2.在工程中创建java目录、resources目录

![image-20200626163726262](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626163726262.png)

### 3.修改java目录和resouces目录的作用

在java目录上右键--》Mark Directory AS--》Source Root
resouces上右键--》Mark Directory AS--》reSource Root

 ![image-20200626164403898](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626164403898.png)

### 4．在maven的web工程中添加tomcat插件运行项目

#### 4.1 修改pom文件，添加Tomcat插件

```java
<bulid>
<!--添加tomcat插件-->
  <plugins>
      <plugin>
          <groupId>org.apache.tomcat.maven</groupId>
          <artifactId>tomcat7-maven-plugin</artifactId>
          <version>2.2</version>
          <!--如果configuration不加，默认端口为8080
              path 项目名称
              port 表示端口
              servlet 表示服务器名称tomcat7
          -->
          <configuration>
              <path>/</path>
              <port>8080</port>
              <server>tomcat7</server>
          </configuration>
      </plugin>
  </plugins>
<bulid>
```

#### 4.2.使用内嵌的tomcat运行工程

![image-20200626164521841](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626164521841.png)

## 四、搭建springmvc配置

(重点)使用springmvc框架（版本4.3.3）的步骤：

### 1.导入springmvc相关的jar包(添加依赖)

 

```xml
<!-- 初始化框架的版本号 -->
<properties>
  <spring.version>4.3.3.RELEASE</spring.version>
</properties>

<dependencies>
 <!--spring支持的相关依赖和springmvc依赖(spring-web、spring-webmvc)-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-oxm</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-support</artifactId>
    <version>${spring.version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>${spring.version}</version>
  </dependency>
  <!-- 引入Spring 依赖 end -->
```



###   2． 添加springmvc的配置文件(springmvc.xml)：存于resources目录

复制现有的springmvc配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:mvc="http://www.springframework.org/schema/mvc"
xmlns:context="http://www.springframework.org/schema/context"
   xsi:schemaLocation="
    http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
     http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-4.3.xsd
     http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
   ">
   <!--配置用户控制器的-->
</beans>
```

### 3.修改web.xml文件:配置核心控制器

```xml
<!--核心控制器
   1.拦截所有的用户请求，并根据请求的名称分发到用户控制
   2.读取sprignmvc配置文件
-->
<servlet>
  <servlet-name>springmvc</servlet-name>
<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:springmvc.xml</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>springmvc</servlet-name>
  <!--拦截的请求-->
  <url-pattern>/</url-pattern>
</servlet-mapping>
```



注意：问题一:如果web.xml文件存在以下错误:没有servlet的环境

![image-20200626170056645](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626170056645.png)

 解决:在pom文件中添加以下依赖

```xml
 <!--添加servlet的依赖-->
<dependency>
  <groupId>javax.servlet</groupId>
  <artifactId>javax.servlet-api</artifactId>
  <version>3.0.1</version>
  <scope>provided</scope>
</dependency>
```

## 五、 创建springmvc控制器的步骤

注意:控制器类以后都统一放到:xxx.xxx.controller包中.

### 1.新建一个类，实现org.springframework.web.servlet.mvc.Controller接口，并重写handleRequest方法

```java
//创建控件器类
public class LoginController  implements  Controller {
    //处理请求的方法
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
处理请求的代码
System.out.println("我是控制器,可以处理请求啦");
        return null;
    }
}
```

### 2.在springmvc配置文件中，定义控制器

```java
 <!--配置用户控制器的-->
<!--定义控制器  配置控制器的请求路径
<bean name="请求路径" class="控制器类限定名称"></bean>
-->
<bean name="/login" class="com.kgc.controller.LoginController"></bean>
```



### 3.发请求访问控制器

## 六、(综合练习)实现登入的业务:

用户是admin   密码:123

### 1.制作表单

```java
<%@ page language="java" pageEncoding="utf-8" contentType="text/html; utf-8" %>
<html>
<body>
<form name="form" method="post" action="login">
    用户名:<input type="text" name="uname"><br/>
    密码:<input type="text" name="password"><br/>
    <input type="submit" value="登入" name="sub"><br/>
</form>
</body>
</html>
```

### 2.编写控制器实现登入的验证

```java
public class LoginController implements Controller {
    @Override   //处理请求的方法
    public ModelAndView handleRequest(HttpServletRequest request,
                                      HttpServletResponse response) throws Exception {
        //System.out.println("可以处理请求啦....");
        //1.取值
        String uname=request.getParameter("uname");
        String password=request.getParameter("password");
        //2.比较验证
        ModelAndView mav=null;
        if(uname.equals("admin")&&password.equals("123")){
            //返回成功页
            //ModelAndView mav=new ModelAndView("网页路径");
            mav=new ModelAndView("success.jsp");
        }else{
            //返回登入页
            mav=new ModelAndView("index.jsp");
        }
        return mav;
    }
}
注意:控制器类需要在springmvc配置文件中进行配置
<bean name="/login" class="com.kgc.controller.LoginController"></bean>
```

## 七、 视图模型对象(ModelAndView)

### 1.创建模型视图对象

ModelAndView mav=new ModelAndView("网页路径");

### 2.给模型视图对象添加数据  (底层还是将数据放到作用域)

mav.getModel().put("键",值);
 mav.getModel().put("name","我会使用模型对象");
[注意:视图页面中还是通过el表过式获取数据]()















------

# ==注解，参数传值day08_springmvc_ch02==



![image-20200626173221230](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626173221230.png)

流程

![img](https://img-blog.csdnimg.cn/20190408151658886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zsb2F0aW5nX2RyZWFtaW5n,size_16,color_FFFFFF,t_70)

1、用户发送请求至前端控制器DispatcherServlet。

2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。

（**handlerMapping的作用**

handlerMapping根据用户请求找到执行该请求的controller。

handlerMapping的找到controller过程

a.根据配置文件对url到controller的映射进行注册

b.根据具体的url请求找到执行该请求的controller）

3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、 DispatcherServlet调用HandlerAdapter处理器适配器。

5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。

6、Controller执行完成返回ModelAndView。

7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。

8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。

9、View解析后返回具体View.

10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 

11、DispatcherServlet响应用户。

SpringMVC常用注解及其作用
@Controller：标识这个类是一个控制器
@RequestMapping：给控制器方法绑定一个uri
@ResponseBody：将java对象转成json，并且发送给客户端
@RequestBody：将客户端请求过来的json转成java对象
@RequestParam：当表单参数和方法形参名字不一致时，做一个名字映射
@PathVarible：用于获取uri中的参数,比如user/1中1的值
Rest风格的新api
@RestController相当于@Controller+ @ResponseBody
@GetMapping@DeleteMapping@PostMapping@PutMapping其他注解
@SessionAttribute：声明将什么模型数据存入session
@CookieValue：获取cookie值
@ModelAttribute：将方法返回值存入model中
@HeaderValue：获取请求头中的值

## 课程目标

1.Springmvc处理请求乱码解决
[2.(重点)实现springmvc注解控制器
3.(重点)掌握控制器中请求方法定义
4.(重点)Springmvc参数绑定]()

## 一、在web.xml文件中添加以下配置解决springmvc取值乱码问题



```java
 <!--配置解决乱的过滤器-->
<filter>
    <filter-name>encodingFilter</filter-name>    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## 二、（重点）注解控制器的步骤:

### 1.在springmvc配置文件中:使用component-scans标签扫描springmvc注解配置

```java
<context:component-scan base-package="控制器包所在包名:com.team.controller"></context:component-scan>
```

注意:在springmvc配置文件中导入context标签

```java
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation=”http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-4.3.xsd”
```



### 2.使用@Controller注解定义控制器

@Controller   //指定当前类为控制器

```java
public class LoginController2 {
 //定义一系列处理请求的方法: 一个请求一个方法
}
```

### 3.使用@RequestMapping注解定义处理请求的方法

```java
方式一:定义控制器方法返回ModelAndView
//@RequestMapping(value = "/请求路径")    //配置请求路径
@RequestMapping(value = "/login2")
public ModelAndView handlerLogin(){
    System.out.println("我可以处理请求啦...");
    return null;
}


定义控制方法二(推荐):返回String  表示视图页面
@RequestMapping("/login6")
public String login6(HttpSession session, String username, String password, Model model){
   处理请求代码….    
        return "index.jsp";
}
```





## 三、springmvc的参数绑定(控制器方法的参数)

###  1.利用ServletApi获取请求中的数据

```java
@RequestMapping("/login2")
public ModelAndView login2(HttpServletRequest request, HttpSession session){
    //1.利用servletapi获取请求参数
    String uname=request.getParameter("uname");
    String password=request.getParameter("password");
    ModelAndView mav=null;
    if(uname.equals("admin")&&password.equals("123")){
        //使用session保存登入的人
        session.setAttribute("loginname",uname);
        //登入成功
        mav=new ModelAndView("success.jsp");
    }else {
        //登入失败
        mav=new ModelAndView("index.jsp");
    }
    return mav;
}
```

###  2.利用参数绑定获取请求中的数据

[一个表单对象(请求中的参数)对应一个方法的参数,要求表单对象名称与参数名称相同]()

```java
@RequestMapping("/login3")
public ModelAndView login3(@RequestParam(value = "username",required = false) String username, String password,HttpSession session){
    //1.利用参数绑定获取请求中的数据
    //一个表单对象(请求中的参数)对应一个请求方法参数,请求中的参数名称与方法参数名称相同即可.
    //2.利用@RequestParam注解指定请求参数与方法参数对应
    //value指定请求参数名称  required表示参数 false可有可无 true一定传
    //@RequestParam(value = "请求参数名称",required = false)
    ModelAndView mav=null;
    if(username.equals("admin")&password.equals("123")){
        mav=new ModelAndView("success.jsp");
        //使用session对象保存登入的人
        session.setAttribute("loginname",username);
    }
    else
    {
        mav=new ModelAndView("index.jsp");
    }
    return mav;  //跳转
}
```

### 3.将多个表单对象(请求中的参数)对应到实体参数中,要求表单对象名称与实体类的属性名称名称相同

```java
@RequestMapping(value = "/login4")
public ModelAndView login4(HttpSession session,User user){
//@RequestParam 用在方法参数上，用于指定请求参数
//利用参数绑定请求的数据:
//将多个表单对象(请求中的参数)对应到实体参数中,要求表单对象名称与实体类的属性名称相同
ModelAndView mav=null;
if(user.getUsername().equals("admin")&&user.getPassword().equals("123")){
    //使用session保存登入的人
    session.setAttribute("info",user.getUsername());
    mav=new ModelAndView("success.jsp");
}
else
    mav=new ModelAndView("index.jsp");
return mav;
}
```





## 四、控制器将数据传递给页面

### 1.利用ModelAndView

### 2.利用参数的Model对象传递数据

```java
//定义控制器请求的方法返回String,String表示返回的网页路径
@RequestMapping("/login5")
public String login5(User user, HttpSession session, Model model){   //表示返回网页路径
    if(user.getUname().equals("admin")&&user.getPassword().equals("123"))
    {
       session.setAttribute("loginname",user.getUname());
        //利用Model对象参数将控制器的数据，传递页面展示
        //model.addAttribute("键",值);
        model.addAttribute("user",user);
        return "success.jsp";//返回网页  默认就是请求转发跳转
    }else{
        return "index.jsp";
    }
}
```

## 五、视图与控制器之间传递数据

![image-20200626174433049](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626174433049.png)

1.视图通过方法参数传值给控制器
2.控制器利用Model对象传递数据[model.addAttribute("键",值);]()











------

# springmvc+mybatis采用三层架构实现功能，day09_springmvc_ch03

## 课程目标:

1.总结控制器与视图之间的数据传递
2.(会)视图解析器
3.综合练习:springmvc+mybatis采用三层架构实现功能
》》实现查询所有学生业务

## 一、(重点理解)总结控制器与视图页面之间的数据传递

![image-20200626195514131](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626195514131.png)

```java
   //1.在控制器方法参数中添加Model对象进行数据传递
    //model.addAttribute("键",值);
    model.addAttribute("userinfo",userInfo);
```

## 二、配置springmvc的视图解析器

### 1.修改springmvc配置文件定义视图解析器

```java
 <!--配置视图解析器-->
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
   <!--前缀-->
   <property name="prefix" value="/"></property>
   <!--后缀-->
 <property name="suffix" value=".jsp"></property>
</bean>
```

### 2.在控制器方法中返回视图名称即可(针对请求转发跳转)

```java
    return "success";   //返回视图名称(文件名)
结果：
  return “success.jsp”
```

扩展:以重定向的方式返回页面
（控制器就不能使用model给页面返回数据、视图解析也不起作用啦）
 return “redirect:返回视图页面的路径”;

## 三、采用三层架构实现学生查询

技术:springmvc+mybatis

![image-20200626195725505](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626195725505.png)

### 1.创建maven工程

添加源码目录、资源文件目录、用包组织分层架构

![image-20200626195736405](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626195736405.png)

### 2.(关键)搭建springmvc和mybatis的开发环境

#### 2.1搭建mybatis的开发环境

导入依赖

```xml
<!-- MySQL依赖 start -->
<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>5.1.25</version>
</dependency>
<!-- MySQL依赖 end -->
!-- 加入MyBatis 依赖 start -->
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis</artifactId>
  <version>3.2.5</version>
</dependency>
<!-- 加入MyBatis 依赖 end -->
<!-- mybatis自动生成所需的依赖start -->
<dependency>
  <groupId>org.mybatis.generator</groupId>
  <artifactId>mybatis-generator-core</artifactId>
  <version>1.3.3</version>
</dependency>
<!-- mybatis自动生成所需的依赖end -->
```

注意:解决maven打包问题

```xml
 <!--配置相关的资源进行打包-->
<resources>
  <resource>
    <directory>src/main/java</directory>
    <includes>
      <include>**/*.xml</include>
    </includes>
  </resource>
  <resource>
    <directory>src/main/resources</directory>
    <includes>
      <include>**/*.*</include>
    </includes>
  </resource>
</resources>
```

添加mybatis相关的配置文件并做出相应修改


```xml
<configuration>
   <!--配置实体类 类型的别名-->
   <typeAliases>
      <package name="com.kgc.project.entity"></package>
   </typeAliases>

<!-- 指定义连接数据的配置 -->

   <environments default="development">
      <environment id="development">
         <transactionManager type="JDBC"/>
         <dataSource type="POOLED">
            <property name="driver" value="com.mysql.jdbc.Driver"/>
            <property name="url" value="jdbc:mysql://localhost:3306/k9051db?useUnicode=true&amp;characterEncoding=utf-8"/>
            <property name="username" value="root"/>
            <property name="password" value="123"/>
         </dataSource>
      </environment>
   </environments>

   <!-- 加载sql映射文件 -->
   <mappers>
       <!--一个一个加载-->
      <!--<mapper resource="com/team/dao/GradeMapper.xml"/>
      <mapper resource="com/team/dao/StudentsMapper.xml"/>-->
      <!--加载指定包下的所有sql映射文件-->
      <package name="com.kgc.project.mapper"></package>
   </mappers>
</configuration>
```

#### 2.2搭建springmvc的开发环境 

导入依赖

```xml
<!-- 初始化框架的版本号 -->
<properties>
  <spring.version>4.3.3.RELEASE</spring.version>
</properties>
<!--spring支持的相关和springmvc依赖(spring-web、spring-webmvc)-->
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-web</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-webmvc</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-core</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-oxm</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-tx</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-jdbc</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-aop</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context-support</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-test</artifactId>
  <version>${spring.version}</version>
</dependency>
<!-- 引入Spring 依赖 end -->

<!--添加jstl的依赖-->
<!-- JSTL -->
<dependency>
  <groupId>jstl</groupId>
  <artifactId>jstl</artifactId>
  <version>1.2</version>
</dependency>
<!-- 加入ServletAPI -->
<dependency>
  <groupId>javax.servlet</groupId>
  <artifactId>servlet-api</artifactId>
  <version>2.3</version>
  <scope>provided</scope>
</dependency>
```

添加springmvc配置文件,并做出相应修改

```xml
 <!--使用component-scans标签扫描springmvc注解配置-->
<context:component-scan base-package="com.kgc.project.controller"></context:component-scan>
<!--配置视图解析器-->
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
   <!--前缀-->
   <property name="prefix" value="/"></property>
   <!--后缀-->
   <property name="suffix" value=".jsp"></property>
</bean>
```

修改web.xml文件(配置核心控制器，解决乱码问题)
 <!--核心控制器
 作用1:拦截用户发请求，根据请求的名称，去springmvc配置文件中找到对应的控制器进行分发
 作用2:读取配置文件，加载所有请求
-->

```xml
<servlet>
  <servlet-name>springmvc</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:springmvc.xml</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>springmvc</servlet-name>
  <!--拦截的请求-->
  <url-pattern>/</url-pattern>
</servlet-mapping>

  <!--配置解决乱的过滤器-->
  <filter>
      <filter-name>encodingFilter</filter-name>
      <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
      <init-param>
          <param-name>encoding</param-name>
          <param-value>utf-8</param-value>
      </init-param>
  </filter>
  <filter-mapping>
      <filter-name>encodingFilter</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>
```

## 四、实现mybatis的反向工程:生成实体，接口，sql映射文件

略   
    [注意:开发项目的功能时，基础]()

## 五、实现查询所有学生信息

### 1.编写dao层

采用自动生成，已经存在持久化操作(略)
[注意:没如没有持久化操作需要自己编写持久化]()

### 2.编写业务层

一业务一功能一方法
接口方法：

```java
public interface StudentService {
    //一业务一功能一方法
    public List<Students> getAllStudent();
}
```

实现:

```java
@Override
public List<Students> getAllStudent() {
    //调用dao层，省了dao实现，需要用getMapper生成dao实现
    SqlSession sqlSession=MyBatisUtil.getSession();
    StudentsMapper studentsMapper=sqlSession.getMapper(StudentsMapper.class);
    //调用dao层方法
   List<Students> list= studentsMapper.selectByExample(new StudentsExample());
   return list;
}
```

### 3.编写表示层

控制器:

```java
 @Controller
public class StudentController {
    //创建业务对象
    StudentService studentService=new StudentServiceImpl();
    @RequestMapping("/showStudent")
    public String showStudent(Model model){
       //调用业务
      List<Students> list=studentService.getAllStudent();
      //利用model对象将数据传递到页面
      model.addAttribute("list",list);
      return "index";  //视图解析支持
    }
}
```

Jsp视图展示：

```jsp
<%@page language="java" contentType="text/html;utf-8" pageEncoding="utf-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<body>
<table>
    <tr>
        <td>学号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>性别</td>
        <td>地址</td>
        <td>状态</td>
        <td>生日</td>
    </tr>
    <c:forEach items="${list}" var="s">
        <tr>
            <td>${s.xh}</td>
            <td>${s.name}</td>
            <td>${s.age}</td>
            <td>${s.sex}</td>
            <td>${s.address}</td>
            <td>${s.state}</td>
            <td>${s.birthday}</td>
        </tr>
    </c:forEach>
</table>
</body>
</html>
```











------

# ==异步请求day10_springmvc_ch04==

## 课程目标:

1.实现学生添加
》》强化springmvc
》》springmvc支持日期转换 @ DateTimeFormat
2.(重点)Springmvc实现异步(springmvc返回异步数据)
2.1利用out对象输出异步数据
2.2利用@ResponseBody注解返回json数据

## 一、实现添加学生

表单:
添加学生

```html
<form id="form1" name="form1" method="post" action=" addStuAction ">
    <p>学号:
        <input type="text" name="xh" id="textfield" />
    </p>
    <p>姓名:
        <input type="text" name="name" id="textfield2" />
    </p>
    <p>性别:
        <input type="text" name="sex" id="textfield3" />
    </p>
    <p>年龄:
        <input type="text" name="age" id="textfield4" />
    </p>
    <p>生日:
        <input type="date" name="birthday" id="textfield5" />
    </p>
    <p>地址:
        <input type="text" name="address" id="textfield6" />
    </p>
    <p>状态:
        <input type="text" name="state" id="textfield7" />
    </p>
    <p>年级:
        <input type="text" name="gid" id="textfield8" />
        <input type="submit" name="button" id="button" value="提交" />
    </p>
</form>
```

### 1.编写dao

略(自动生成已经存在持久化操作) 

### 2.编写业务

接口方法:

```java
public int addStudent(Students students);
```

实现:

```java
@Override
    public int addStudent(Student stu) {
        //利用sqlSession获取dao层接口的动态实现类
        int temp=-1;
        try {
            SqlSession sqlSession=MyBatisUtil.getSession();
            StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);
            temp=studentMapper.insertSelective(stu);
//提交
sqlSession.commit();
        }catch (Exception e){
            e.printStackTrace();
        }
        finally{
            MyBatisUtil.closeSession();
        }
        return temp;
    }
}
```

### 3.编写表示层

控制器:

```java
//一个请求一个方法
@RequestMapping("/addStudent")
public String addStudent(Student student){
    //student学生对象接收表单数据，要求类的属性名称与表单对象名相同
    //调用业务实现添加
    int temp=this.studentService.addStudent(student);
    if(temp>0)
    {  //成功
        // 跳转查询控制器
        return "redirect:showStudent";
    }else{ //失败
        return "addStu";  //返回视图
    }
}
```



## 二、springmvc支持日期的转换(控制器对接表单对象输入日期时)

### 1.修改springmvc配置文件，添加注解驱动支持

```xml
<mvc:annotation-driven></mvc:annotation-driven>
```

### 2.修改实体日期属性，使用@DataTimeFormat支持日期转换

```java
@DateTimeFormat(pattern = "yyyy-MM-dd")
private Date birthday;
```

## 三、(知识点：掌握)Springmvc实现异步技术:控制器返回异步数据

### 1.回顾Ajax的工作原理

![image-20200626211414272](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626211414272.png)

XMLHttpRequest

### 2.控制器利用out对象输出返回数据

```java
//方式一:利用out对象输出返回的json数据
@RequestMapping("/getData")
public void getData(HttpServletResponse response) throws IOException {
    //设置响应的编码
    response.setContentType("text/html;charset=utf-8");
    PrintWriter out=response.getWriter();
    //1.返回字符串
    //out.print("hello");
    //2.返回json
    out.print("[\"张三\",\"李四\",\"麻子\"]");
}
```

### 3.利用@ResponseBody注解实现返回异步数据的步骤

#### 3.1导入jackson的依赖



```xml
 <!-- 添加jackson支持  start-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.5</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.5</version>
</dependency>
<!-- 添加jackson支持 end -->
```



#### 3.2修改springmvc配置文件添加mvc注解驱动

```xml
<mvc:annotation-driven></mvc:annotation-driven>
```

#### 3.3 编写控制器利用@Reponsebody返回数据

```java
//方式二:使用@ResponseBody注解返回异步数据
//注意:@responsebody注解表示将返回的内容输出到网页、
//支持默认采用jackson工具包将java对象转化为json字符串返回
@RequestMapping("/getData2")
@ResponseBody
public List<Student> getData2(){
    //调用业务获取所有的学生信息
    StudentService studentService=new StudentServiceImpl();
    List<Student> list=studentService.getAllStudent();
    //将java对象转化为json进行输出
    return list;
}
```

## 四、使用springmvc+mybatis+ajax+mysql技术实现学生信息的展示

![image-20200626212101939](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626212101939.png)

### 1.编写获据所有学生的业务

略

### 2.编写控制器(如何返回所有学生数据呢?)

```java
//方式二:使用@ResponseBody注解返回异步数据
//注意:@responsebody注解表示将返回的内容输出到网页、
//支持默认采用jackson工具包将java对象转化为json字符串返回
@RequestMapping("/getData2")
@ResponseBody
public List<Student> getData2(){
    //调用业务获取所有的学生信息
    StudentService studentService=new StudentServiceImpl();
    List<Student> list=studentService.getAllStudent();
    //将java对象转化为json进行输出
    return list;
}
```

### 3.编写前端:使用jquery的ajax方法发送异步请求展示数据

  

```java
 <%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script language="JavaScript" type="text/javascript" src="js/jquery-1.8.3.min.js"></script>
    <script language="JavaScript" type="text/javascript">
        //发送异步请求获取学生信息展示
        $(function(){ //加载事件
             //点击事件
            $("#but1").click(function(){
               //发送异步请求获取数据展示
               $.post("getData2",null,function(data){
                   //以表格的方式显示数据
                   var table='<table border=2><tr><td>学号</td><td>姓名</td><td>年龄</td><td>性别</td></tr>';
                   for(var i=0;i<data.length;i++){
                       var obj=data[i];
                       table=table+'<tr><td>'+obj.xh+'</td><td>'+obj.name+'</td><td>'+obj.age+'</td><td>'+obj.sex+'</td></tr>';
                   }
                   table=table+"</table>";
                   //显示
                   $("#showInfo").html(table);
               },"json");

            });
        });

    </script>
</head>
<body>
  <input id="but1" type="button" name="ss" value="加载学生信息">
  <div id="showInfo"></div>
</body>
</html>
```







## 五、其它

### 1.解决springmvc静态访问

![image-20200626212558767](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626212558767.png)

答:修改springmvc配置文件添加以下代码

```xml
<!--springmvc配置文件中, 启用默认Servlet-->
<mvc:default-servlet-handler/>
```









------

# 初始spring，day11_springch01

## 课程目标:

1.介绍Spring和搭建Spring的环境
2.理解Spring IoC的原理 重点 难点
3.掌握Spring IoC的配置重点 难点

编程思想:
面向过程->面向对象->面向接口->面向组件(Spring的IOC)->面向切面(Spring的Aop)->面向服务

## 一、介绍spring

### 1．Spring是一个轻量级框架，Java EE的春天。

Spring框架可以理解:组装型框架。
    

### 2.spring目标:

使现有技术更加易用，推进编码的最佳实践.

### 3.spring包含的内容:

IOC容器、AOP实现、数据访问支持(提供JdbcTemplate对象简化Jdbc操作、简化Mybatis操作)、web集成(springmvc支持)

## 二、Spring的IOC(控制反转)

### 1.什么是IOC:

  将组件(类)对象的控制权从代码本身转移到[外部容器(spring容器)]()的过程称为控制反转(IOC).
 注意;控制反转的目的是实现程序的解藕

![image-20200626214314693](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200626214314693.png)

### 2.搭建spring的开发环境实现IOC的步骤:

#### 2.1导入spring框架依赖

```xml
 <properties>
    <!--指定springmvc的版本-->
    <spring.version>4.3.3.RELEASE</spring.version>
</properties>
<dependencies>
   <!--spring依赖 start-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-support</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-oxm</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aop</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <!-- 引入Spring 依赖 end -->
</dependencies>
```

#### 2.2添加spring框架的配置文件(applicationContext.xml)并存于resources目录

```xml
 <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:context="http://www.springframework.org/schema/context"
   xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
    http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-4.3.xsd">
</beans>
```



#### 2.3在spring配置文件中使用bean标签创建对象(IOC实现)

```xml
<!-- 使用bean标签添创建bean对象
<bean id="bean对象id" class="类的限定名"></bean>
-->
 <bean id="student" class="com.Student"></bean>
```



### 3.使用spring容器中的对象的步骤

```java
//1.创建spring容器
ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");
//2.使用getBean方法获取容器中的对象
//ctx.getBean("bean对象的id值")
Student stu=(Student) ctx.getBean("student");
//3.使用对象
stu.setXh(101);
stu.setName("张三");
stu.setSex("男");
stu.show();
```





## 三、依赖注入(理解:利用依赖注入给类的私有属性赋值)

目的:将组件对象的构建和使用分离

### 1.依赖注入的方式

属性注入、构造注入、工厂注入….

### 2.使用property标签进行属性注入

#### 2.1 注入基本类型(包含String) 使用value属性

```java
<property name="属性名称" value="101"></property>
```

#### 2.2 注入对象类型(包含String) 使用ref属性

```xml
<property name="属性名称" ref="bean对象的id值"></property>
```



示例:

```xml
<!--使用bean标签创建类的对象(实现IOC)
 <bean id="bean对象的名称" class="类的限定名称"></bean>
-->
<bean id="stu" class="com.kgc.Student">
 <!--使用property标签实现属性注入:实现类的私有 属性赋值-->
    <property name="xh" value="102"></property>
    <property name="name" value="张三"></property>
    <property name="sex" value="男"></property>
    <property name="address" ref="address"></property>
</bean>
<!--创建地址对象-->
<bean id="address" class="com.kgc.Address">
      <property name="bh" value="4300"></property>
<property name="info" value="湖北武汉某区1090"></property>
</bean>
```

### 3.使用p命名空间注入(简化属性注入)

[p:属性名=”值”  注入基本类型  
 p:属性名-ref=”bean对象的id值”  注入对象类型]()

```xml
<!--p命名空间注入： 简化属性注入-->
<bean id="student2" class="com.Student" p:xh="102" p:name="麻子" p:sex="女" p:address-ref="address">
</bean>
```

注意:使用p命名空间注入必需在beans标签中必需导入p命名空间

```java
xmlns:p="http://www.springframework.org/schema/p"
```



### 4.使用构造注入

注意:构造注入必需依赖于构造方法
示例:

```xml
<!--使用constructor-arg实现构造注入：实现学生属性的初始化-->
   <bean id="stu3" class="com.kgc.Student">
   <!--
    一个constructor-arg标签代表一个构造方法的参数
    value属性给基本类型  ref属性指对象类型
    index属性指定参数的顺序，不指定就按参数的顺序传递
   -->
   <constructor-arg value="习大大" index="1"></constructor-arg>
   <constructor-arg value="103" index="0"></constructor-arg>
   <constructor-arg value="男" index="2"></constructor-arg>
   <constructor-arg ref="address" index="3"></constructor-arg>
</bean>
```

学生类中添加构造方法:
注意：添加构造方法时一定添加默认构造

```java

//学生类中添加构造方法:
//注意：添加构造方法时一定添加默认构造
public Student(){}  //默认构造
public Student(Integer xh, String name, String sex, Address address) {
    this.xh = xh;
    this.name = name;
    this.sex = sex;
    this.address = address;
}
```



## 扩展:类与类之间的关系

1.继承关系(纵向关系)
2.利用类的属性实现:横向关系

```java
Class Person{
   Private Car car=new Car();//   1 对 1 
   Private List<Car> cars=new ArrayList<Car>; // 1对多

}
Class Car{
  Private List<Person> cars=new ArrayList< Person >; // 1对多

}
```

















------

# ==《aop》day12_spring_ch02==



## 课程目标

1.(掌握)IOC注入不同的数据类型
2.理解AOP原理(重点 难点)
3.(会)AOP实现

## 一、使用依赖注入不同的数据类型

![image-20200629083518089](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200629083518089.png)

### 1.使用value标签注入直接量

```xml
<property name="xh">
    <value>102</value>
</property>
```

### 2.使用ref标签引用bean对象

```xml
 <property name="address">
   <ref bean="address"></ref>
    <!—定义本地bean对象
<bean class="com.Address" p:bh="101" p:info="不详"></bean>
</property>
```

### 3.注入集合类型

集合分类:[List集合、set集合、map集合]()、propertes集合(键值集合:键值都字符串)

```xml
<!--注入List集合-->
<property name="tels">
    <list>
        <value>13260601227</value>
        <value>13260601228</value>
        <value>13260601229</value>
    </list>
</property>
<!--注入Set集合-->
<property name="adds">
    <set>
        <ref bean="address"></ref>
        <bean class="com.Address" p:bh="104" p:info="不详1"></bean>
        <bean class="com.Address" p:bh="105" p:info="不详2"></bean>
    </set>
</property>
<!--注入键值对象集合map-->
<property name="cjs">

    <map>
        <!--entry表示一个键值对-->
        <entry key="语言" value="90"></entry>
        <entry key="数学" value="80"></entry>
        <entry key="英语" value="10"></entry>
    </map>

</property>

<!--注入键值对象集合properties
private Properties propcjs; //键值对集合
-->
<property name="propcjs">
    <props>
        <prop key="语言">90</prop>
        <prop key="数学">100</prop>
        <prop key="英语">99</prop>
    </props>
</property>
```

### 4.注入空值和空字符串

使用<null/> 表示空对象
使用<value></value> 表示空字符串

## 二、spring的AOP思想 (面向切面编程)

面向切面编程:其实就是对方法[进行拦截、实现增强处理]()

### 1.AOP的目标：让我们可以“专心做事”

### 2.AOP原理

将复杂的需求分解出不同方面，将散布在系统中的公共功能集中解决
采用代理机制组装起来运行，在不改变原程序的基础上对代码段[进行增强处理]()，增加新的功能

### 3.实现AOP面向切面编程的步骤:

#### 3.1定义增强类

##### a.创建前置增强(Advice)

[创建一个类实现org.springframework.aop.MethodBeforeAdvice
接口并重写before方法]()

```java
//前置增强类
//代理对象，增强类
public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override  //重写方法
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("method:"+method.getName());
        for (Object o:args) {
            System.out.println("参数:"+o);
        }
        System.out.println("target:"+target.toString());
        System.out.println("我准备开始计算啦....");
    }
}
```

##### b.定义增强类的bean对象,有可能被拦截的方法的bean对象(拦截的目标对象)

[注意:只有spring创建的对象才能进行面向切面]()

```xml
<!--目标对象-->
<bean id="mathTools" class="com.aop.MathTools"></bean>
<!--定义增强类的对象:前置增强-->
<bean id="mybeforeAdvice" class="com.aop.MyBeforeAdvice"></bean>
```



##### c.植入切面

```xml
<!--织入切面配置-->
 <aop:config>
   <!--定义切入点  指定拦截方法-->
   <aop:pointcut id="pointcut" expression="execution(public int getSum(int,int))"></aop:pointcut>
       <!--指定增强对象-->
   <aop:advisor pointcut-ref="pointcut" advice-ref="myBeforeAdvice"></aop:advisor>
</aop:config>
```

注意:导入aop标签

```java
xmlns:aop="http://www.springframework.org/schema/aop"
xsi:schemaLocation="http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"
```






注意:实现aop切面编程需要导入以下依赖:

```xml
<dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-aspects</artifactId>
         <version>4.2.8.RELEASE</version>
   </dependency>
```



## 三、定义方法切入点

1.（public int getSum(int,int)）  表示方法名getSum带两个整型参数，返回为int

2.(* one.aop.MathTools.*(..))表示MathTools类下所有的方法，任意参数，任意返回值都切

3.(* *(..))表示所有方法，任意参数，任意返回值都切

4.(* one.aop.*.*(..))表示aop包下所有类的所有方法，任意参数，任意返回值都切

5com.aop..*.*(..) 表示aop包下所有类级其子包下所类的所有方法，任意参数，任意返回值都切

[应用场景：共性集中解决(增强类)]()

## 四、使用后置增强

### [a.定义后置增强类:创建类实现org.springframework.aop.AfterReturningAdvice 并重写afterReturning方法]()

```java
public class MyAfterAdvice implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object returnValue,
                               Method method,
                               Object[] args,
                               Object target) throws Throwable {
        System.out.println("计算结束...");
        System.out.println("当前方法返回的结果是"+o);
        System.out.println("方法是"+method);
        System.out.println("传递的参数是"+objects[0]);
        System.out.println("返回的类型是"+o1);
    }
}
```

### b.在spring配置文件中配置增强bean对象

```java
<!--定义后置增强类的对象-->
<bean id="myafterAdvice" class="com.aop.MyAfterAdvice"></bean>
```

### c.配置切入点

```java
<aop:advisor advice-ref="myafterAdvice" pointcut-ref="pointcut"></aop:advisor>
```



扩展:

## 五、java的属性文件(理解为文件型的键值对集合)

### 1.1扩展名是 properties

### 1.2作用:充当java配置文件出现

### 1.3存储格式

键=值
键=值
示例:jdbc.properties

```properties
jdbc.url=jdbc:mysql://localhost:3306/db
jdbc.driverClass=com.jdbc.mysql.Driver
jdbc.username=root
jdbc.password=123
```

### 1.4使用properties对象读取属性文件中的内容

```java
public static void main(String[] args) throws IOException {
    //使用Properties加载属性文件的内容
    Properties properties=new Properties();
    //1.加载属性文件中的数据
    FileReader fileReader=new FileReader("E:\\IdeaProjects\\K0501\\springch01\\src\\main\\resources\\jdbc.properties");
    properties.load(fileReader);
    //2.显示数据
    properties.forEach((o, o2) -> {
        System.out.println("键:"+o+"值:"+o2);
    });
}
```













------



# day13 ssm整合

## 课程目标:

1.Spring+Springmvc+Mybatis三大框架整合(简称为:SSM)

理解ssm整合的思路
[spring整合Mybatis框架
spring整合SpringMVC]()
2.结合SSM实现学生查询

## 一、 理解SSM三大框架

### 1.回顾三层架构

![image-20200630145250185](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630145250185.png)

### 2.SSM整合思路

a从流程来看浏览器发送请求到控制器，控制器调用业务，业务调用service，service调用dao，dao层通过sqlsession调用具体方法，然后通过connection获取数据库数据，再反着传递数据到页面

![image-20200630145306701](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630145306701.png)

### 3.SSM架构

Spring + SpringMVC + Mybatis
以Spring作为核心框架，数据持久化使用Mybatis完成，表现层使用springmvc 
Spring提供对象管理、面向切面编程等实用功能
通过Spring提供的服务简化编码、降低开发难度、提高开发效率

## 二、使用ssm实现学生查询

### 1.创建工程

![image-20200630145327441](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630145327441.png)

### 2.在项目中添加三大框架的支持(重点)

#### 2.1添加三大框架的依赖：mybatis、springmvc、spring

参考文件

#### 2.2添加三大框架的配置文件

##### a.添加mybatis配置文件并修改

定义实体别名、配置数据库(不要啦)、加载sql映射

##### b.添加sprngmvc的配置文件并修改

修改web.xml文件(配置核心控制器、乱码过滤器)

##### c.添加spring的配置文件

#### 3.反向工程

生成实体，接口，sql映射文件

#### 4.修改pom文件

添加resources标签用于解决java目录中的xml文件打包问题 
添加tomcat插件 

```xml
<!--配置相关的资源进行打包-->
<resources>
  <resource>
    <directory>src/main/java</directory>
    <includes>
      <include>**/*.xml</include>
    </includes>
  </resource>
  <resource>
    <directory>src/main/resources</directory>
    <includes>
      <include>**/*.*</include>
    </includes>
  </resource>
</resources>

<!--添加tomcat插件-->
<plugins>
  <plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.2</version>
    <!--如果configuration不加，默认商品为8080
        path 项目名称
        port 表示端口
        servlet 表示服务器名称tomcat7
    -->
    <configuration>
      <path>/</path>
      <port>8080</port>
      <server>tomcat7</server>
    </configuration>
  </plugin>
</plugins>
```

## 三、Spring整合Mybatis的步骤(重点):在applicationContext.xml配置文件中添加以下配置

[必需导入: mybatis-spring依赖包]()

```xml
<!--spring整合mybatis-->
   <!--1.定义数据源组件c3p0  作用：用于连接数据库-->
   <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
   <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
   <property name="url" value="jdbc:mysql://localhost:3306/k9051db?useUnicode=true&amp;characterEncoding=utf-8"></property>
   <property name="username" value="root"></property>
   <property name="password" value="123"></property>
</bean>
<!--2.定义sqlSessionFactory工厂组件-->
   <bean id="sqlSessionFatory" class="org.mybatis.spring.SqlSessionFactoryBean">
   <!--指定数据源-->
   <property name="dataSource" ref="dataSource"></property>
   <!--指定mybatis的配置文件-->
   <property name="configLocation" value="classpath:mybatis-config.xml"></property>
</bean>

<!--3.spring接管dao层组件 (理解为创建dao层实现类的对象)
  注意:1. sql映射的命名空间必需是接口的限定名，持久化操作的id值必需和接口方法中相同

<!--3.spring接管dao层组件 (理解为创建dao层实现类的对象)
  注意:1. sql映射的命名空间必需是接口的限定名，持久化操作的id值必需和接口方法中相同

            2. 动态生成实现类的bean对象id值，就是接口名称首字母小写
               -->
               <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
                  <!--指定sqlSessionFacory对象-->
                  <property name="sqlSessionFactoryBeanName" value="sqlSessionFatory"></property>
                  <!--扫描dao层接口，动态生成实现类的对象-->
                  <property name="basePackage" value="com.kgc.grade.mapper"></property>
               </bean>
```





自己的理解

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	   xmlns:context="http://www.springframework.org/schema/context"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
	 http://www.springframework.org/schema/beans
	 http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
	  http://www.springframework.org/schema/context
	 http://www.springframework.org/schema/context/spring-context-4.3.xsd
	   http://www.springframework.org/schema/tx
	http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
	  http://www.springframework.org/schema/mvc
	http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
	">
	<!--spring整合mybatis-->
	<!--1.定义数据源组件c3p0  作用：用于连接数据库-->
	<!--BasicDataSource                          使用BasicDataSource创建一个简单的数据库连接池工具类
	这一步的作用是通过c3p0连接数据库，在spring容器中就是通过这一步连接数据库的，所以mybatis-config.xml文件中的链接数据库的配置就算不要也可以
	因为连接数据库在这里连接
	-->
	<bean id="configurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations">
			<list>
				<value>classpath:jdbc.properties</value>
			</list>
		</property>
	</bean>

	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${driverClass}"></property>
		<property name="url" value="${url}"></property>
		<property name="username" value="${username}"></property>
		<property name="password" value="${password}"></property>
	</bean>

	<!--2.定义sqlSessionFactory工厂组件-->
	<bean id="sqlSessionFatory" class="org.mybatis.spring.SqlSessionFactoryBean">
       <!--指定数据源-->
        <!--指定数据源用于连接数据库，引用刚才创建好的dataSource数据源对象-->
        <property name="dataSource" ref="dataSource"></property>
        <!--指定mybatis的配置文件-->
        <!--给出mybatis-config.xml文件位置，这样就可以读取mybatis-config.xml文件里的，映射文件的位置，找出起好别名的实体类了，读取相应数据了-->
        <property name="configLocation" value="classpath:mybatis-config.xml"></property>
    </bean>

    <!--3.spring接管dao层组件 (理解为创建dao层实现类的对象)
  注意:1. sql映射的命名空间必需是接口的限定名，持久化操作的id值必需和接口方法中相同
         2. 动态生成实现类的bean对象id值，就是接口名称首字母小写
-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!--指定sqlSessionFacory对象-->
        <!--因为属性名name要求的是sqlSessionFactoryBeanName，所以后面跟的是value而不是ref-->
      <!--因为要用到sqlSession生成mapper接口中所有的实现类，所以引用sqlSessionFactory工厂组件，生成sqlSession-->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFatory"></property>
        <!--扫描dao层接口，动态生成实现类的对象-->
        <!--扫描com.kgc.grade.mapper中所有的接口，并且自动创建接口中所有的实现类
       这样就不用像以前每次通过getmapper动态获取一个实现类了，而是扫描mapper中所有的的，
       接口自动生成所有实现类对象，并放在spring容器中，这样省事了不少，当你需要某一个
       实现类时，直接到spring容器中拿就行了
          要注意的是扫描接口，自动生成的实现类对象的类名是：接口名称首字母小写
        -->
        <property name="basePackage" value="com.team.appinfo.mapper"></property>
    </bean>

    <!--扫描业务组件配置  注意:扫描业务实现类的对象-->
    <!--添加了此扫描就会自动在业务实现类impl文件下扫描所有注解只要发现注解，就会
    在spring容器中自动创建一个bean对象-->
    <context:component-scan base-package="com.team.appinfo.service.impl"></context:component-scan>
	<!--配置Spring的事务管理器 -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>

	</bean>
	<!-- 注解方式配置事物 -->
	<tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
</beans>


```



## 四、开发业务组件，并交给spring容器接管

### 1.在spring配置文件中添加扫描业务组件对象

```xml
<!--扫描业务组件配置  注意:扫描业务实现类的对象-->
<context:component-scan base-package="com.kgc.grade.service.impl"></context:component-scan>
```

### 2.开发业务组件

```java
接口:
public interface StudentService {
    public List<Students> getAllStudent();
}
```

```java
实现: 
//@Service(value = "studentSerivce")  //表示业务组件  组件id为"studentSerivce"
@Service  //表示业务组件  组件id为实现类的首字小写
public class StudentServiceImpl implements StudentService {
    //声明dao层接口属性
    //使用@Autowired进行自动注入 默认按类型
    //从容器中找相应接口的对象进行自动赋值
    @Autowired
    private StudentsMapper studentsMapper;
    @Override
    public List<Students> getAllStudent() {
        return this.studentsMapper.selectByExample(new StudentsExample());
    }
}
```



 理解@Service注解和@Autowire注解

![image-20200630150532552](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630150532552.png)

## 五、编写控制器控制器.(spring整合springmvc无缝集成)

注意:在springmvc配置文件中添加控制器扫描的配置



```java
@Controller
public class StudentController {
    //定义业务接口的属性
    @Autowired(required = false) //自动注入(省略setter和getter方法)  按类型区配
    private StudentService studentService;
@RequestMapping("showStudent")
public String showStudent(Model model){
     //调用业务
    List<Students> list=studentService.getAllStudent();
     //填充model
    model.addAttribute("list",list);
    return "index";
}
}
```

## 六、编写视图层代码

```html
 学生信息如下:<br/>
<table>
    <tr>
        <td>学号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>性别</td>
        <td>地址</td>
        <td>生日</td>
        <td>状态</td>
    </tr>
    <c:forEach items="${list}" var="l">
        <tr>
            <td>${l.xh}</td>
            <td>${l.name}</td>
            <td>${l.age}</td>
            <td>${l.sex}</td>
            <td>${l.address}</td>
            <td>${l.birthday}</td>
            <td>${l.state}</td>
        </tr>
    </c:forEach>
</table>
```



## 七、在web.xml文件中使用监听器[启动spring容器]()

```xml
 <!--启动spring容器-->
<!--指定spring配置文件的位置-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```















------

# ==day14 ssm整合二(程序事务，增，删)==

## 课程目标:

1.(掌握)优化数据源的配置
2.(掌握)配置ssm整合的事务支持（spring事务配置）
3.添加学生信息
4.删除学生 

## 一、优化数据源的配置:jdbc连接的参数定义在属性文件中

### 1.定义jdbc.properties属性文件

```properties
driverClass=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/k9051db?useUnicode=true&characterEncoding=utf-8
username=root
password=123
```

​    

#### 2.在spring配置文件中使用PropertyPlaceholderConfigurer类加载属性文件

```xml
<bean id="configurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    name为location代表一个属性
    name为locations代表一个集合
   <property name="locations">
      <list>
         <value>classpath:jdbc.properties</value>
      </list>
   </property>
</bean>
```

#### 3.在spring配置使用[${属性文件中的键]()}引用属性文件中的值

```xml
     <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
   <property name="driverClassName" value="${driverClass}"></property>
   <property name="url" value="${url}"></property>
   <property name="username" value="${username}"></property>
   <property name="password" value="${password}"></property>
</bean>
```

## 二、配置ssm框架整合的事务支持

#### 1.事务分类:

数据库事务、程序事务

#### 2.理解程序中事务

注意:ssm事务是添加在业务实现上的

![image-20200630152701479](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630152701479.png)    

#### 3.实现事务支持的注解配置

##### 3.1修改spring配置文件添加事务支持的配置

注意:在spring配置文件中导入tx标签

```xml
xmlns:tx="http://www.springframework.org/schema/tx"
xsi:schemaLocation=" 
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"
```



```xml
 <!--配置Spring的事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
   <property name="dataSource" ref="dataSource"/>
</bean>
<!-- 注解方式配置事物 -->
<tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
```

注意:在spring配置文件中导入tx标签

```xml
xmlns:tx="http://www.springframework.org/schema/tx"
xsi:schemaLocation=" 
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"
```

##### 3.2在业务类中使用[@transactional]()注解支持事务

 @Transactional     [注意:放在类上表示类中所有方法都基于事务执行]()
public class TestServiceBean implements TestService {….}

 

```java

//当类中某些方法不需要事物时:

@Transactional
public class TestServiceBean implements TestService {   
    //挂起事务，不基地事务执行
@Transactional(propagation = Propagation.NOT_SUPPORTED)
    public List<Object> getAll() {
        return null;
    }   
}
```

####   4.注意:

##### 4-1.添加事务支持的业务方法中不能使用try..catch语句,因为事务实现是业务方法报时进切面的事务增强处理.

##### 4-2.@Transactional的propagation属性，表示事务的传播机制

了解:Spring中七种Propagation类的事务属性详解： 
 REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 
 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 
 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 
 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 
 NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。 

## 三、(掌握)在maven工程中编写主函数测试业务组件

```java
public class StudentServiceImpl
{
    public static void main(String[] args) {
        //1.从spring容器中获取业务组件对象
        ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");
        StudentService studentService=(StudentService)ctx.getBean("studentServiceImpl");
        //2.调用业务方法
        studentService.delMoreStudent();
        System.out.println("成功执行");
    }
}
```



## 四、添加学生

### 1．查询的年级信息显示到学生表单中

#### 1.1编写dao层

略

1.2编写业务层
接口方法:

```java
public interface GradeService {
    //查询所有年级
    public List<Grade> getAllGrade();
}
```

实现:

```java
@Service   //创业业务对象后期注入到控制器使用
public class GradeServiceImpl implements GradeService {
    //调用dao层   声明属性，等着注入
    @Autowired   //自动注入
    private GradeMapper gradeMapper;
    @Override
    public List<Grade> getAllGrade() {
        return gradeMapper.selectByExample(new GradeExample());
    }
}
```

#### 1.3编写控制层



```java
@Controller
public class GradeController {
    //引入业务
    @Autowired
    private GradeService gradeService;
@RequestMapping("/goAddStudent")
public String  goAddStudent(Model model){
   //调用业务获取数据，在页面中展示
   List<Grade> list=gradeService.getAllGrade();
   //将数据填充到Model
    model.addAttribute("list",list);
   return "addStudent";  //视图解析器
}
}
```



#### 1.4编写视图:  添加学生表单  addStudent.jsp

```html
 <form id="form1" name="form1" method="post" action="addStu">
    <p>学号:
        <input type="text" name="xh" id="textfield" />
    </p>
    <p>姓名:
        <input type="text" name="name" id="textfield2" />
    </p>
    <p>性别:
        <input type="radio" name="sex" value="男"/>男
        <input type="radio" name="sex"  value="女" />女
    </p>
    <p>年龄:
        <input type="text" name="age" id="textfield4" />
    </p>
    <p>生日:
        <input type="date" name="birthday" id="textfield5" />
    </p>
    <p>地址:
        <input type="text" name="address" id="textfield6" />
    </p>
     <p>年级:
   <select name="gid">
        <c:forEach items="${list}" var="g">
          <option value="${g.gid}">${g.gname}</option>
        </c:forEach>
   </select>
    <input type="submit" name="button" id="button" value="提交" />
</p>
     </form>
```

### 2.添加学生

#### 2.1编写dao层

略

#### 2.2编写业务层

接口方法:

```java
public int addStudent(Students students);
```

实现 ：

```java
@Override
public int addStudent(Students students) {
    return studentsMapper.insertSelective(students);
}
```

#### 2.3编写控制器

```java
 @RequestMapping("/addStudent") //属性名与表音对象名称对应
public String addStudent(Students stu) {
    //设置在读状态为:0，（只要在调用业务方法之前，就可以手动的重新设置Student里的任意属性）
    stu.setState(new Byte("0"));
    //调用业务
    int temp = studentService.addStudent(stu);
    if (temp > 0)  //去显示
        return "redirect:showStudents";
    else
        return "redirect:showGrade";
}


```

## 五、实现删除学生

### 1.编写dao层

反向工程   存在删除的方法
略

### 2.编写业务层  学生的业务类中添加以下方法

接口:

```java
//删除学生
public int delStudent(Integer xh);
```

实现:

```java
@Override
public int delStudent(Integer xh) {
    return studentsMapper.deleteByPrimaryKey(xh);
}
```

### 3.编写控制器

```java
 //删除学生请求   传递学号
@RequestMapping("/delStuAction")
public String delStuAction(Integer xh){  //使用实体自动接收表单对象的值
    //调用业务
    int temp=studentService.delStudent(xh);
    return "redirect:showStudent";
}
```

```html
<td><a href="javaScript:if(confirm('确定删除吗？')){location.href='deleteStudent?xh=${l.xh}'}">删除</a>
```

（任务）重点看spring的配置文件(基础，每个项目都要有这些配置)

### 4.记住常用类

  记住常用类
   PropertyPlaceholderConfigurer    加载属性文件（properties）文件要用到此类
   BasicDataSource                          使用BasicDataSource创建一个简单的数据库连接池工具类
   SqlSessionFactoryBean                sqlSessionFatory工厂组件，用于获取SqlSession
   MapperScannerConfigurer          对象生成dao层接口实现类的对象（之前是用getmapper动态实现接口实现类，在spring                    容器中则是使用MapperScannerConfigurer          对象生成接口实现类）
   DataSourceTransactionManager  事务管理器（管理事务）
ContextLoaderListener启动spring容器的类



4-1.是什么
  PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。

作用
  在Spring中，使用PropertyPlaceholderConfigurer可以在XML配置文件中加入外部属性文件，当然也可以指定外部文件的编码。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改

 4-2  BasicDataSource
BasicDataSource类实现了DataSource接口，可以用于DBCP连接池的简单使用。
  4-3 SqlSessionFactoryBean
在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的，而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。要创建工厂 bean，将下面的代码放到 Spring 的 XML 配置文件中：
要注意的是 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口。这意味着由 Spring 最终创建的 bean 并不是 SqlSessionFactoryBean 本身，而是工厂类（SqlSessionFactoryBean）的 getObject() 方法的返回结果。

   4-4MapperScannerConfigurer
a.自动扫描 将Mapper接口生成代理注入到Spring

MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中


b.把Mapper接口转换成MapperFactoryBean


其实在SqlSessionFactoryBean 里面就已经实现了注册了 MapperProxyFactory 到Mybatis


c.这里做的是把它们托管到spring


  4-5 DataSourceTransactionManager  事务
Spring的事务处理中，通用的事务处理流程是由抽象事务管理器AbstractPlatformTransactionManager来提供的，而具体的底层事务处理实现，由PlatformTransactionManager的具体实现类来实现，如 DataSourceTransactionManager 、JtaTransactionManager和 HibernateTransactionManager等。
在这里用到DataSourceTransactionManager进行事务管理，可能需要多条sql完成对数据库的操作，比如账户登录，需要匹配用户名和密码，然后要增加积分，还要记录登录的ip和时间，这可能需要三个sql语句，这三个语句应当是一个整体，任意一个sql执行不成功，都表示这个业务没有执行完成，对前面的sql执行进行回滚。
　　事务是数据库中的概念，就是对数据库的一组操作，由一条或多条sql组成。
　　事务具有同步的特点，一条sql执行失败，其他sql都不会执行，即要么都执行，要么都不执行





### 5.常用注解

（1）@Controller   //指定当前类为控制器（相当于通过controller注解在springmvc容器里创建了一个对象）
（2）@RequestMapping注解定义处理请求的方法
（3）@DateTimeFormat(pattern = "yyyy-MM-dd")使用@DataTimeFormat支持日期转换
但是前提是<mvc:annotation-driven></mvc:annotation-driven>
（4）使用@ResponseBody注解返回异步数据（就是自动将java对象转换为json进行输出，相当于狗肾）
但是要添加jackson依赖，修改springmvc配置文件<mvc:annotation-driven></mvc:annotation-driven>
（5）//@Service(value = "studentSerivce")  //表示业务组件  组件id为"studentSerivce"
@Service  //表示业务组件  组件id为实现类的首字小写
（只要加了service标签，在spring容器中自动创建此类对象）
（6）  @Autowired//使用@Autowired进行自动注入 默认按类型
    //从容器中找相应接口的对象进行自动赋值（使用 @Autowired标签就可以从spring容器中获取你想要得到的对象信息了
，只要价格私有属性当做全局变量就可用了，比如private StudentsMapper studentsMapper;）
   （7）使用@transactional()注解就可以支持程序事务

























------

# day15 ssm整合修改学生和分页插件



## 课程目标:

1.实现学生信息修改

显示当前学生信息
修改学生信息
2.(重点)PageHelper插件实现分页
PageHelper使用步骤
实现学生信息分页展示

## 一、实现修改学生展示(查询单条件数据信息):还原表单

### 1.编写dao层

略

### 2.编写业务层:通过学号查询学生信息

接口:

```java
public Students getStudent(Integer xh);
```

实现:

```java
@Override
public Students getStudent(Integer xh) {
    return studentsMapper.selectByPrimaryKey(xh);
}
```

### 3.编写控制器

```java
//获取学生信息请求   传递学号
@RequestMapping("/getStudent")
public String getStudent(Integer xh,Model model){
    Student stu=this.studentService.getStudent(xh);
    //将学生信息填充到模型
    model.addAttribute("s",stu);
    //查询所有年级
    model.addAttribute("list",this.gradeService.getAllGrade());
    return "upStu";
}
```

### 4.前端页面展示:

```html
 <%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

<html>
    <head>
    <title>Title</title>
</head>
    <body>
编辑学生
        <form id="form1" name="form1" method="post" action="addStudent">
    <p>学号:
        <input type="text" value="${s.xh}" name="xh" id="textfield" />
    </p>
    <p>姓名:
        <input type="text" value="${s.name}" name="name" id="textfield2" />
    </p>
    <p>性别:
        <input type="radio" ${s.sex=="男"?"checked":""} name="sex" value="男">男
        <input type="radio" ${s.sex=="女"?"checked":""} name="sex" value="女">女
    </p>
    <p>年龄:
        <input type="text" value="${s.age}" name="age" id="textfield4" />
    </p>
    <p>生日:
        <input type="date" value="<fmt:formatDate pattern="yyyy-MM-dd" value="${s.birthday}"/>"  name="birthday" id="textfield5" />
    </p>
    <p>地址:
        <input type="text" value="${s.address}" name="address" id="textfield6" />
    </p>
    <p>状态:
        <input type="text" value="${s.state}" name="state" id="textfield7" />
    </p>
    <p>年级:
       <%-- <input type="text" name="gid" id="textfield8" />--%>
        <select name="gid">
            <c:forEach items="${list}" var="g">
                <option ${g.gid==s.gid?"selected":""} value="${g.gid}">${g.gname}</option>
            </c:forEach>
        </select>
        <input type="submit" name="button" id="button" value="更新" />
    </p>
</form>
        </body>
</html>
```

注意: date表单对象还原数据、下拉列表如何选中

##  二、 实现学生的修改功能:

### 1.编写dao层

略

### 2.编写业务层

接口方法:

```java
//修改
public int updateStudent(Student stu);
```

实现:

```java
@Override
public int updateStudent(Student stu) {
    return studentsMapper.updateByPrimaryKeySelective(stu);
}
```

### 3.编写控制层

```java
@RequestMapping("/updateSudent")
public String updateSudent(Student student){
    //student接收表单数据
    //调用业务实现保存
    int temp=this.studentService.updateStudent(student);
    if(temp>0)
    return "redirect:showStudent";
    else
    return "redirect:getStudent?xh="+student.getXh();
}
```

### 4.修改学生的表单

[注意:表单提交时，表单对象的名称必需和实体属性名称相同.]()



## 三、 实现学生信息分页:

在mybatis中使用分页插件(PageHelper)实现分页.

### 1.在项目中添加PageHelper的依赖

```xml
<!--添加mybatis分页插件支持-->
<dependency>
  <groupId>com.github.pagehelper</groupId>
  <artifactId>pagehelper</artifactId>
  <version>5.0.0</version>
</dependency>
```

### 2.在mybatis配置文件中定义分页插件

```xml
 <!--配置分页的插件-->
<plugins>
   <plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
</plugins>
```

### 3.在业务层实现分页

接口方法:

```java
/**
 
  * 分页查询所有学生信息
  * @param curPage  页码
  * @param pageSize  页大小
  * @return PageInfo 表示分页的实体信息
  * (包含分页的相关数据:页码，页大小，总记录数，当前页的数据..)
    **/
 PageInfo<Students> getStudentByPage(Integer curPage,Integer pageSize);

```

实现:

 ```java

public PageInfo<Students> getStudentByPage(Integer curPage,Integer pageSize)
 {
     //1.开启分页查询  每页三条
     //PageHelper.startPage(页码,页大小);
     PageHelper.startPage(curPage,pageSize);
     //2.查询所有信息
     StudentsExample studentsExample=new StudentsExample();
     List<Students> list=this.studentsMapper.selectByExample(studentsExample);
     //3.获取分页相关的信息
     PageInfo<Students> pageInfo=new PageInfo<>(list); //传当前页数的数据
     /*
      获取分页的相关信息
     System.out.println("当前页:"+pageInfo.getPageNum());
     System.out.println("页大小:"+pageInfo.getPageSize());
     System.out.println("总页数:"+pageInfo.getPages());
     System.out.println("总记录数:"+pageInfo.getTotal());
     System.out.println("下一页:"+pageInfo.getNextPage());
     System.out.println("上一页:"+pageInfo.getPrePage());
     System.out.println("当前页的数据:"+pageInfo.getList().size());*/
     /*分页插件的工作流程:
             1.开启分页后，PageInterceptor激活
               作用:拦截接下来执行的查询语句
             2.修改sql语句添加分页支持
     select * from student limit 开始位置，读取长度;*/
     return pageInfo;
 }
 ```

注意：
1.当你所选的页数已经是第一页时，那么当你再获取上一页（PageInterceptor）时，你获得的值是0，因为你现在已经是第一页了，获取上一页，页数时是0，如果不把第一页的上一页固定为0的话，那你再点击上一页就会变成-1导致出现错误，为了避免错误，就直接把第一页的上一页固定为0了
2.当你所选的页数已经是最后一页时，那你获取下一页（PageInterceptor）的值也会为0，原因和上面一样，已经是最后一页没有数据了，那你再点击下一页就会出错，所以就自动固定为0了

### 4.控制器:

```java
/分页查询的控制器   传递页码:pageNum
@RequestMapping("/getPageStudent")
public String getPageStudent(Integer pageNum, Model model){
     //调用业务实现分页
    PageInfo<Student> pageInfo=this.studentService.getStudentByPage(pageNum==null?1:pageNum,5);
     //填充分页信息
    model.addAttribute("pageInfo",pageInfo);
    return "indexPage";
}
```



### 5.视图页面

```html
<%@ page contentType="text/html; charset=utf-8" pageEncoding="UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<body>
    <h2>所有信息如下:</h2>
<table border="2">
    <tr>
        <td>学号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>性别</td>
        <td>生日</td>
        <td>地址</td>
        <td>年级</td>
        <td>操作</td>
    </tr>
    <c:forEach items="${pageInfo.list}" var="s">
        <tr>
            <td>${s.xh}</td>
            <td>${s.name}</td>
            <td>${s.age}</td>
            <td>${s.sex}</td>
            <td>${s.birthday}</td>
            <td>${s.address}</td>
            <td>${s.gid}</td>
            <td><a href="javascript:if(confirm('确定想删除吗?')) location.href='delStudent?xh=${s.xh}';">删除</a>
                <a href="getStudent?xh=${s.xh}">修改</a></td>
        </tr>
    </c:forEach>
</table>
<div>
    <div>每页${pageInfo.pageSize}条,当前是第${pageInfo.pageNum}页,共${pageInfo.pages}页,共${pageInfo.total}条记录</div>
    <div>
        <a href="getPageStudent?pageNum=1">首页</a>
        <a href="getPageStudent?pageNum=${pageInfo.prePage==0?1:pageInfo.prePage}">上一页</a>
如果上一页等于零时，那就说明本页已经是第一页了，所以上一页等于0时，就可以让它等于第一页了，再点击上一页也没有数据了
        <a href="getPageStudent?pageNum=${pageInfo.nextPage==0?pageInfo.pages:pageInfo.nextPage}">下一页</a>
当下一页等于0时，说明本页已经等于最后一页了，在点击下一页也不会有数据了，所以当下一页等于0时就让他默认等于最后一页
（注意：当上一页没有数据时，默认为0，下一页也是如此，当你非要手动添加一个负数时，也会自动默认为1，让你手动添加一个超出尾页的数据时，会默认为空一页也不显示）
        <a href="getPageStudent?pageNum=${pageInfo.pages}">尾页</a>
    </div>
    <div>
        <select onchange="location.href='getPageStudent?pageNum='+this.value;">
            <option value="">请选择页码</option>
           <c:forEach begin="1" end="${pageInfo.pages}" var="i" step="1">
               <option ${i==pageInfo.pageNum?"selected":""} value="${i}">第${i}页</option>
           </c:forEach>
        </select>
    </div>
</div>
    </body>
</html>
```



![image-20200701171314175](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200701171314175.png)

浏览器发送页码给后台，后台返回页码信息给页面





扩展:删除添加确认提示框:

```html
<a href="javascript:if(confirm('确定想删除吗?')) location.href='delStuAction?xh=${s.xh}';">删除</a>
```

## 个人总结

1.

plugins插件
interceptor拦截
PageInterceptor只要开启分页（PageInterceptor），PageInterceptor拦截器就会启动发挥作用，它会拦截执行第一条sql ，并修改sql语句实现分页，但是此类只有在mabatis中才会发生作业















------

# ==day16 day16 条件+连接查询+bootstrap==



## 目标:

1.带条件查询分页
2.连接查询
3.介绍bootstrap前端框架

## 一、带条件分页展示

　分析:

浏览器传递页码和查询条件（可以把页码和查询条件分别写成两个类，然后让条件类继承分页类，这样如果有再多的条件也不用担心了，分页也可以在分页类中自由修改，是个很不错的方式）到控制器。

​    控制器再调用业务，业务调用dao层，然后从数据库中返回数据，然后按照反着的过程把分页条件查询后的信息给到页面

![image-20200702162201926](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200702162201926.png)

### 1.创建条件实体 和 分页实体  放到工具包中util

#### 1-1、分页实体

```java
public class PageParmeter {  //分页实体
    private Integer page=1;  //页码
    private Integer pageSize=5;  //页大小
}
```

#### 1-2、条件实体

```java
 //学生查询条件  放到实体包中
public class StudentCondition extends PageParmeter {
   //一个条件一个属性
    private String name;
    private Integer startAge;
    private Integer endAge;
    setter和getter
}
```

### 2.编写Dao层

```java
List<Students> selectByExample(StudentsExample example);
```

 支持条件查询:无需编写dao

 支持条件查询:无需编写dao

### 3.编写业务层

接口方法:

```java
/**

 * 带条件的分页查询
 * @param studentCondition  查询条件
 * 包含查询条件和分页参数
 * @return pageInfo
   */
   public PageInfo<Student> getStudentByCondition(StudentCondition studentCondition);
```

实现:

```java
 @Override
public PageInfo<Student> getStudentByCondition(StudentCondition studentCondition) {
        //1.开启分页        PageHelper.startPage(studentCondition.getPage(),studentCondition.getPageSize());
        //2.调用dao层进行条件查询
        StudentExample studentExample=new StudentExample();
        StudentExample.Criteria criteria=studentExample.createCriteria();
        //封装查询条件
        if(studentCondition.getName()!=null)
            criteria.andNameLike("%"+studentCondition.getName()+"%");
        if(studentCondition.getStartAge()!=null)            criteria.andAgeGreaterThan(studentCondition.getStartAge().byteValue());
        if(studentCondition.getEndAge()!=null)            criteria.andAgeLessThan(studentCondition.getEndAge().byteValue());
        List<Student> list=this.studentMapper.selectByExample(studentExample);  //持久化
        //3.创建pageInfo对象返回信息
         return new PageInfo<Student>(list);
}
```

### 4.编写控制器

```java
 //条件分页查询
@RequestMapping("/searchStudent")
public String searchStudent(StudentCondition studentCondition,Model model){
     //调用业务查询
     PageInfo<Student> pageInfo=this.studentService.getStudentByCondition(studentCondition);
     //填充返回的数据
     model.addAttribute("pageInfo",pageInfo);  //分页信息
     model.addAttribute("condition",studentCondition); //查询的条件信息
     return "indexPage";
}
```

### 5.前端展示，回显，分页

#### 实现思路:

##### 1.显示当前页的数据

##### 2.实现搜索及回显示条件

##### 3.实现搜索条件的分页导航:

<span style="color:red">给表单设置跳转的页面(利用隐藏域)、提交表单(传递当前页码和查询条件)</span>

```html
 <%@ page contentType="text/html; charset=utf-8" pageEncoding="UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<body>
     <h2>所有信息如下:</h2>
<form name="form1" id="form1" method="post" action="searchStudent">
     <!--利用隐藏域传递页码-->
    <input type="hidden" name="page" id="setPage" value="1">
    姓名:<input type="text" name="name" value="${condition.name}" />
    年龄:<input type="text" name="startAge"  value="${condition.startAge}"/>-<input type="text"value="${condition.endAge}" name="endAge"/>
    <input type="submit" value="搜索" name="ss"/>
</form>
<table border="2">
    <tr>
        <td>学号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>性别</td>
        <td>生日</td>
        <td>地址</td>
        <td>年级</td>
        <td>操作</td>
    </tr>
    <c:forEach items="${pageInfo.list}" var="s">
        <tr>
            <td>${s.xh}</td>
            <td>${s.name}</td>
            <td>${s.age}</td>
            <td>${s.sex}</td>
            <td>${s.birthday}</td>
            <td>${s.address}</td>
            <td>${s.gid}</td>
            <td><a href="javascript:if(confirm('确定想删除吗?')) location.href='delStudent?xh=${s.xh}';">删除</a>
                <a href="getStudent?xh=${s.xh}">修改</a></td>
        </tr>
    </c:forEach>
</table>
<div>
    <div>每页${pageInfo.pageSize}条,当前是第${pageInfo.pageNum}页,共${pageInfo.pages}页,共${pageInfo.total}条记录</div>
    <div>
        <a href="javascript:goPage(1)">首页</a>
        <a href="javascript:goPage(${pageInfo.prePage==0?1:pageInfo.prePage})">上一页</a>
        <a href="javascript:goPage(${pageInfo.nextPage==0?pageInfo.pages:pageInfo.nextPage})">下一页</a>
        <a href="javascript:goPage(${pageInfo.pages})">尾页</a>
    </div>
    <div>
        <select onchange="goPage(this.value)">
            <option value="">请选择页码</option>
           <c:forEach begin="1" end="${pageInfo.pages}" var="i" step="1">
               <option ${i==pageInfo.pageNum?"selected":""} value="${i}">第${i}页</option>
           </c:forEach>
        </select>
    </div>
</div>
   </body>
</html> 
               <script language="JavaScript" type="text/javascript" src="js/jquery-1.8.3.min.js"></script>
<script language="javaScript" type="text/javascript">
    //跳转分页的方法
    function goPage(pageNum){
        //alert("我要显示第"+pageNum+"页");
        //1.设置当前的页码
        $("#setPage").val(pageNum);
        //2.提交搜索的表单  分页导航传递搜索条件
        $("#form1").submit();  //提交表单
    }
</script>
```











## 二、查询学生的同时关联年级名称

Mybatis执行连接查询(针对多表)

### 1、首先: 修改学生实体添加年级名称属性，以便实体传递数据

```java
/添加额外年级名称
private String gname;

public String getGname() {
    return gname;
}

public void setGname(String gname) {
    this.gname = gname;
}
```





### 2、编写dao层

接口:

```java
//带条件查询所有
List<Student> getStudentByCondition (StudentCondition studentCondition);
```

持久化操作:

```xml
<!--搜索学生信息-->
<select id="getStudentByCondition" resultType="Student" parameterType="com.kgc.grade.util.StudentCondition">
    SELECT student.*,gname FROM student LEFT JOIN grade ON
    student.gid=grade.`gid` where 1=1
    <if test="name !=null">
       and name like concat('%',#{name},'%')
    </if>
    <if test="startAge !=null">
       and age > #{startAge}
    </if>
    <if test="endAge !=null">
      and age &lt; #{endAge}
    </if>
</select>
```







### 3、编写业务层

接口方法:

```java
/**

 * 条件查询分页
 * @param studentCondition  学生查询条件+分页参数
 * @return 学生信息
   */
   public PageInfo<Students> getStudentByCondition (StudentCondition studentCondition);
```

实现:

```java
 @Override
public PageInfo<Students> getStudentByCondition(StudentCondition studentCondition) {
    //1.开启分页
    PageHelper.startPage(studentCondition.getPage(),studentCondition.getPageSize());
    //2.利用selectByExample实现条件查询 或者 自己编写持久化方法
    //注意 selectByExample只是基于单表查询
    //2.调用持久化操作:持久化执行的是连接查询
    List<Students> list= studentsMapper. getStudentByCondition (studentCondition);
    return new PageInfo<Students>(list); //获取分页信息
}
```

### 4、控制器层: 

略

### 5、表示层:

略





### 6、扩展:

1.对springmvc  web项目中的静态资源放行 ,在springmvc配置文件中添加以下配置

```java
<!--对项目中的静态资源放行-->
<mvc:resources mapping="/js/**" location="/js/"></mvc:resources>
```







## 三、使用Bootstrap前端框架 

使用Bootstrap前端框架 

### 1、介绍Bootstrap

   Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目.
   注意:编向外观效果

### 2、搭建Bootstrap的环境搭建

#### 2-1、将bootstarp的静态资源复制到项目中.

将satatic目录复到工程中(放到Webapp目录下)

#### 2-2、在网页中引入相关的样式文件和js文件

```html
<!-- 新 Bootstrap 核心 CSS 文件 -->
<link rel="stylesheet" href="static/css/bootstrap.css">
<!-- 可选的Bootstrap主题文件（一般不用引入） -->
<link rel="stylesheet" href="static/css/bootstrap-theme.min.css">
   <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
<script src="static/js/jquery-1.9.1.min.js"></script>
<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
<script src="/static/js/bootstrap.js"></script>
```

### 3、 使用bootstrap

#### 3.1 显示图标

```html
<span class="glyphicon glyphicon-search"></span>
```

#### 3.2显示按钮



```html
<button class="btn btn-default" type="button">我是按钮</button>
```



####    3.3 按钮中添加图标

```html
<button type="submit" class="btn btn-primary" aria-label="Left Align">
        <span class="glyphicon glyphicon-search" aria-hidden="true"></span>搜索
    </button>
```





### 4.控制表格

```html
<table class="table table-striped  table-hover  table-bordered" border="2" width="80%">
```





  